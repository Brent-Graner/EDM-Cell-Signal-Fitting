#include <formatio.h>
#include <utility.h>
#include <ansi_c.h>
#include <cvirte.h>	
#include <userint.h>
#include <analysis.h>  
#include "EDM 8ch PITD Product Frequency Fitting.h"

/******************************************************************************************
Myanal: EDM precession signal fitting program, analyzes data files generated by EDMacq

	121903 WCG: added somewhat flexible handling of number of precession signals generated
					in acqusition program.
					- number of signals specified by NCELLS constant
					- works if NCELLS <= # of actual signals
					- columns in ".cum" and ".bak" files are adjusted appropriately,
					   ",sum" output still is 4 column for now (would need to adjust
					   HgCorrAnal to handle a different ".sum" format)
*******************************************************************************************/

#define NCELLS 4 
#define NEWCELLS 8 /* parameter for 8 channels */	
#define ncoef 5   //#of coefficients to be passed to the fitting routine
#define histmax 5000
#define nback 100


int fit;
double chi[4];
double MidtimeA = 0.0;
double MidtimeB = 0.0;
int aph,fnfh,feh;
static int previousBOLEstate;
static int oldsize;
static int PauseState, PauseOnFNF, SerON, Pick_Up=0,AmpCorr,SingleON=0,manw0=0, DataSeFlag;
//static int mantime0=0;

static double fc;
static double fw;
static double dstartA; //holder values for start, end of each data fitting segment (A and B)
static double dstopA;
static double dstartB;
static double dstopB;
static double dstart; //holder values for fitting range to be passed to AnalData
static double dstop;
static double fstart;
static double fstop;
static double AmpA1,AmpA2,AmpA3,AmpA4,AmpB1,AmpB2,AmpB3,AmpB4,TDark1,TDark2,TDark3,TDark4;  // for dark lifetimes
static double off[4],ang[4];
static double mean[8];
static double *Dphi[2][4][4]; //holds the results of all signal product analysis [sample#][cell#1][cell#2]
static double *Dw[2][4][4]; //holds the results of all phase product analysis [sample#][cell#1][cell#2]
static double *Sphi[2][4][4]; //holds uncertainties in Delta(phi) values from signal product analysis, organized like Dphi[][][]
static double *Sw[2][4][4]; //holds uncertainties in Delta(omega) values from signal product analysis, organized like Dw[][][]

static double *ComboDphi[2][5]; //holds the results of all signal product analysis [sample#][cell#1][cell#2]
static double *ComboDw[2][5]; //holds the results of all phase product analysis [sample#][cell#1][cell#2]
static double *ComboSphi[2][5]; //holds uncertainties in Delta(phi) values from signal product analysis, organized like Dphi[][][]
static double *ComboSw[2][5]; //holds uncertainties in Delta(omega) values from signal product analysis, organized like Dw[][][]

//static double *ComboDphi[2]; //holds the results of all signal product analysis [sample#][cell#1][cell#2]
//static double *ComboDw[2]; //holds the results of all phase product analysis [sample#][cell#1][cell#2]
//static double *ComboSphi[2]; //holds uncertainties in Delta(phi) values from signal product analysis, organized like Dphi[][][]
//static double *ComboSw[2]; //holds uncertainties in Delta(omega) values from signal product analysis, organized like Dw[][][]

static double chi2 = 0.0;
static double midtime = 0.0;
static double TimeDiff = 0.0;
static double shutterOpenA = 0.0; //doubles to hold time values where data trains start and end-output to *.cum file
static double shutterOpenB = 0.0;
static double shutterCloseA = 0.0;
static double shutterCloseB = 0.0;
static double PhiHolder[4] = {0.0,0.0,0.0,0.0}; //holder array for phase difference results    
static double coef[NCELLS*ncoef]; //array to hold coefficients for NCELLS
static double errors[NCELLS*ncoef]; //coefficient error estimates for NCELLS 							  
//static double pseg[(NCELLS+1)*nseg]; //array of phase segment data with nseg extra elements for time values 
//static double psegerr[NCELLS*nseg]; //error estimates for each phase deviation segment
//static double aseg[(NCELLS+1)*nseg]; //array of amplitude deviation data for NCELLS
//static double asegerr[NCELLS*nseg]; //error estimates for amplitude deviation points
static double AmpCoef[16];
static double ProductCoef[NCELLS*5]; //array to hold coefficients product frequency fitting on NCELLS
static double ProductErrors[NCELLS*5]; //product frequency fit coefficient error estimates for NCELLS
static double TS_Dw[6]; //Contains Thiel-Sen estimated slope/freq. differences

static char iname[300],AmpFileName[300];
static char indir[300],outdirsum[300],outdircum[300],outdirfit[300];
static char sersuffix[10];
static char sumname[300];
static char sumsuffix[10];
static char cumname[300];
static char fitname[300];
static int serstart;
static int pumpPts = 0;
static int serstop,sernum;
static int ColorArray[8] = {VAL_GREEN, VAL_YELLOW,VAL_CYAN, VAL_WHITE, VAL_BLUE, VAL_MAGENTA, VAL_GRAY, VAL_RED};
static int SymbolArray[4]={VAL_EMPTY_SQUARE,VAL_EMPTY_CIRCLE,VAL_SOLID_SQUARE,VAL_SOLID_CIRCLE};
static int filetype;
static double *Rawdata = 0;
static double *Rawdata_temp = 0;
static double *Fitdata = 0; //holds the filtered data for one channel # to be fit
static double *TmiddleA = 0; //holder arrays for plotting phase deviation data
static double *TmiddleA_Sum = 0;  //averaged T[] array holder pointers to look for structure on T[] signals
static double *TmiddleA_Avg = 0;
static double *TouterA_Sum = 0;
static double *TouterA_Avg = 0;
static double *Tdiff = 0;
static double *TouterA = 0;
static double *TmiddleB = 0;
static double *TouterB = 0;
static double *TmiddleB_Sum = 0;  //averaged T[] array holder pointers to look for structure on T[] signals
static double *TmiddleB_Avg = 0;
static double *TouterB_Sum = 0;
static double *TouterB_Avg = 0;
static double *TS_Slope = 0;
static double *S[NCELLS]; //declares an array of pointers to hold the fitdata for all channels
static double *Ta[6];  //a block of 6 variable-length arrays to hold the T[] array results from A-period calls to ProductFit
static double *Tb[6];  //arrays to hold the T[] array results from B-period calls to ProductFit

static double *Resid = 0;
static double *Analdata = 0;
static double *Background = 0;
static double Hist[histmax*40];

static double time0;
static double AmpEndA[4]; //Holder values for the signal amplitude at the end of first interrogation period
static double AmpStartB[4]; //holders for signal amp at beginning of second light period
static double TimeEndA[4]; //holders for time values used to fit dark lifetime
static double TimeStartB[4];

static int starti=0;
static int stopi=0;

static int RawPoints,FitPoints,FitPointsA,FitPointsB,AnalPoints;
static int sample = 1; //flag for tracking which data sample is being fit
static int WriteParamString = 1; //flag for putting headers onto *.cum files
static char readfilename[300],sumfilename[300],backfilename[300],cumfilename[300];
static double *Analdata0=0, *Analdata1=0, *Analdata2=0,*Analdata3=0,*Analdata4=0,*AnaldataS=0;
static double *Analdata5=0, *Analdata6=0, *Analdata7=0,*Analdata8=0;
static double om; //average angular frequency (should be ~52.0 for Series 7 data)

int TshortPtsA = 0; //holder variable for number of points in averaged A period T[] array 
int TshortPtsB = 0; //holder variable for number of points in averaged B period T[] array
double TdiffDw[7];  //array to hold results of T[] difference freq. difference method
double TdiffDwErr[7]; //scatter in points of T[]differnce arrays

static int graphsel[4]={0,0,0,0}; //array for holding plot #'s to display 4-channel data on

static int TAvgPts = 12; //number of points to average from T[] into TShort in ProductFit, ProductComboFit

static int FileRead(void);
static int AnalData(int filenum, int sample);
static int FitData(void);
static int WriteSum(void);
static int Guess(void);
static int AddCum(void);
static int AnalyzeFile(void);
static int ProductFit(int cell1, int cell2);

static int ProductComboFit(int cell1, int cell2, double C12, int cell3, int cell4, double C34, int cell5, int cell6, double C56, int listPlace);

double fun(double x, double a[]) ; 
double ampcorr(int i,double x);

double TimeZero = 0.0;
double DOmegaDot12A = 0.0; 
double DOmegaDot34A = 0.0;

extern void NLF(double data_x[], double data_y[], int, double coefs[],int vary[],int, double errors[], int sample);

int main (int argc, char *argv[])
{
	srand (42.0);
	if (InitCVIRTE (0, argv, 0) == 0)	/* Needed if linking in external compiler; harmless otherwise */
		return -1;	/* out of memory */
	if ((aph = LoadPanel (0, "EDM 8ch PITD Product Frequency Fitting.uir", AP)) < 0)
		return -1;
	fnfh=LoadPanel(0,"EDM 8ch PITD Product Frequency Fitting.uir",FNF);
	feh=LoadPanel(0,"EDM 8ch PITD Product Frequency Fitting.uir",FE);  
	
	Rawdata_temp = malloc (1000 * sizeof(double));  
	Rawdata = malloc (1000 * sizeof(double));  
	Fitdata = malloc (1000 * sizeof(double));
	Analdata = malloc (1000 * sizeof(double)); 
	Resid = malloc (1000 * sizeof(double));
	Background = malloc (5*nback*sizeof(double));

	TS_Slope = malloc(sizeof(double)); 
	for(int h=0; h<6; h++) 
		{
		Ta[h] = malloc(sizeof(double));
		Tb[h] = malloc(sizeof(double));
		}
	
	for(int i=0; i<NCELLS; i++)	S[i] = malloc (1000 * sizeof(double));
	
	for(int j=0; j<NCELLS; j++)				/* j=0; j<NCELLS-1; j++ */
		{									/* k=j+1; k<NCELLS-1; k++ */
		for (int k=0; k<NCELLS; k++)
			{
			Dphi[0][j][k] = malloc(sizeof(double));
			Dphi[1][j][k] = malloc(sizeof(double));
			Sphi[0][j][k] = malloc(sizeof(double));			
			Sphi[1][j][k] = malloc(sizeof(double));
			Dw[0][j][k] = malloc(sizeof(double));
			Dw[1][j][k] = malloc(sizeof(double));
			Sw[0][j][k] = malloc(sizeof(double));			
			Sw[1][j][k] = malloc(sizeof(double));
			}
		}
	
//	ComboDphi[0] = malloc(sizeof(double));
//	ComboDphi[1] = malloc(sizeof(double));
//	ComboDw[0] = malloc(sizeof(double)); 
//	ComboDw[1] = malloc(sizeof(double));
//	ComboSphi[0] = malloc(sizeof(double)); 
//	ComboSphi[1] = malloc(sizeof(double)); 
//	ComboSw[0] = malloc(sizeof(double));
//	ComboSw[1] = malloc(sizeof(double));

	for (int m=0; m<5; m++) //allocate space for ProductComboFit results
		{
		ComboDphi[0][m] = malloc(sizeof(double));
		ComboDphi[1][m] = malloc(sizeof(double));
		ComboDw[0][m] = malloc(sizeof(double)); 
		ComboDw[1][m] = malloc(sizeof(double));
		ComboSphi[0][m] = malloc(sizeof(double)); 
		ComboSphi[1][m] = malloc(sizeof(double)); 
		ComboSw[0][m] = malloc(sizeof(double));
		ComboSw[1][m] = malloc(sizeof(double));
		}
	
	DataRange (aph, AP_DataStartA, EVENT_VAL_CHANGED,0, 0, 0); 
	DataRange (aph, AP_DataStopA, EVENT_VAL_CHANGED,0, 0, 0);
	DataRange (aph, AP_DataStartB, EVENT_VAL_CHANGED,0, 0, 0); 
	DataRange (aph, AP_DataStopB, EVENT_VAL_CHANGED,0, 0, 0);
	FitRange (aph, AP_FitStart, EVENT_VAL_CHANGED,0, 0, 0); 
	FitRange (aph, AP_FitStop, EVENT_VAL_CHANGED,0, 0, 0); 
	InitParam (aph, AP_a1_A, EVENT_VAL_CHANGED,0, 0, 0);
	InitParam (aph, AP_a2_A, EVENT_VAL_CHANGED,0, 0, 0);
	InitParam (aph, AP_a3_A, EVENT_VAL_CHANGED,0, 0, 0);
	InitParam (aph, AP_a4_A, EVENT_VAL_CHANGED,0, 0, 0);
	InitParam (aph, AP_t1_A, EVENT_VAL_CHANGED,0, 0, 0);
	InitParam (aph, AP_t2_A, EVENT_VAL_CHANGED,0, 0, 0);
	InitParam (aph, AP_t3_A, EVENT_VAL_CHANGED,0, 0, 0);
	InitParam (aph, AP_t4_A, EVENT_VAL_CHANGED,0, 0, 0);
	InitParam (aph, AP_p1_A, EVENT_VAL_CHANGED,0, 0, 0);
	InitParam (aph, AP_p2_A, EVENT_VAL_CHANGED,0, 0, 0);
	InitParam (aph, AP_p3_A, EVENT_VAL_CHANGED,0, 0, 0);
	InitParam (aph, AP_p4_A, EVENT_VAL_CHANGED,0, 0, 0);
	InitParam (aph, AP_w1_A, EVENT_VAL_CHANGED,0, 0, 0);
	InitParam (aph, AP_w2_A, EVENT_VAL_CHANGED,0, 0, 0);
	InitParam (aph, AP_w3_A, EVENT_VAL_CHANGED,0, 0, 0);
	InitParam (aph, AP_w4_A, EVENT_VAL_CHANGED,0, 0, 0);
	Names (aph, AP_InputDir, EVENT_VAL_CHANGED,0, 0, 0);
	Names (aph, AP_OutputDirCum, EVENT_VAL_CHANGED,0, 0, 0);
	
	Names (aph, AP_InputName, EVENT_VAL_CHANGED,0, 0, 0); 
	Names (aph, AP_SerStart, EVENT_VAL_CHANGED,0, 0, 0);
	Names (aph, AP_SerStop, EVENT_VAL_CHANGED,0, 0, 0);
	Names (aph, AP_SerSuffix, EVENT_VAL_CHANGED,0, 0, 0);
	Names (aph, AP_CumName, EVENT_VAL_CHANGED,0, 0, 0);
	Names (aph, AP_SumName, EVENT_VAL_CHANGED,0, 0, 0);
	Graph_Select (aph, AP_GraphSelect1, EVENT_COMMIT,0, 0, 0);
	Graph_Select (aph, AP_GraphSelect2, EVENT_COMMIT,0, 0, 0);
	Graph_Select (aph, AP_GraphSelect3, EVENT_COMMIT,0, 0, 0);
	Graph_Select (aph, AP_GraphSelect4, EVENT_COMMIT,0, 0, 0);
	FREQCB(aph,AP_FREQ, EVENT_VAL_CHANGED,0,0,0);
	DataSeCB (aph,AP_DataSe, EVENT_COMMIT,0,0,0);
	
	DisplayPanel (aph);
	RunUserInterface ();
	return 0;
}


int CVICALLBACK DataRange (int panel, int control, int event, void *callbackData, int eventData1, int eventData2)
	{
	double ave;
	switch (event) 
		{
		case EVENT_VAL_CHANGED:
			switch (control) 
				{
				case AP_DataStartA:
					GetCtrlVal(aph,AP_DataStartA,&dstartA);
    				previousBOLEstate = GetBreakOnLibraryErrors ();
    				if (previousBOLEstate)
   			 		DisableBreakOnLibraryErrors();
   			 		Mean(&Rawdata[RawPoints], RawPoints, &ave);   
    				SetGraphCursor (aph, AP_Data, 1, dstart, ave); 
					if (previousBOLEstate)
    				EnableBreakOnLibraryErrors();
					fstop=dstop-dstart-5;
					SetCtrlVal(aph,AP_FitStop,fstop);
					break;
				case AP_DataStartB:
					GetCtrlVal(aph,AP_DataStartB,&dstartB);
    				previousBOLEstate = GetBreakOnLibraryErrors ();
    				if (previousBOLEstate)
   			 		DisableBreakOnLibraryErrors();
   			 		Mean(&Rawdata[RawPoints], RawPoints, &ave);   
    				SetGraphCursor (aph, AP_Data, 3, dstart, ave); 
					if (previousBOLEstate)
    				EnableBreakOnLibraryErrors();
					fstop=dstop-dstart-5;
					SetCtrlVal(aph,AP_FitStop,fstop);
					break;
				case AP_DataStopA:
					GetCtrlVal(aph,AP_DataStopA,&dstopA);
					previousBOLEstate = GetBreakOnLibraryErrors ();
           			if (previousBOLEstate)
            		DisableBreakOnLibraryErrors();
            		Mean(&Rawdata[RawPoints], RawPoints, &ave);
                	SetGraphCursor (aph, AP_Data, 2, dstop, ave);   
		   			if (previousBOLEstate)
            		EnableBreakOnLibraryErrors();
					fstop=dstop-dstart-5;
					SetCtrlVal(aph,AP_FitStop,fstop);
					break;
				case AP_DataStopB:
					GetCtrlVal(aph,AP_DataStopB,&dstopB);
					previousBOLEstate = GetBreakOnLibraryErrors ();
           			if (previousBOLEstate)
            		DisableBreakOnLibraryErrors();
            		Mean(&Rawdata[RawPoints], RawPoints, &ave);
                	SetGraphCursor (aph, AP_Data, 4, dstop, ave);   
		   			if (previousBOLEstate)
            		EnableBreakOnLibraryErrors();
					fstop=dstop-dstart-5;
					SetCtrlVal(aph,AP_FitStop,fstop);
					break;
			}		
			break;
		}
	return 0;
	}

int CVICALLBACK FitRange (int panel, int control, int event, void *callbackData, int eventData1, int eventData2)
	{
	switch (event) 
		{
		case EVENT_VAL_CHANGED:
			switch (control) 
				{
				case AP_FitStart:
					GetCtrlVal(aph,AP_FitStart,&fstart);
					break;
				case AP_FitStop:
					GetCtrlVal(aph,AP_FitStop,&fstop);
					break;
				}		
			break;
		}
	return 0;
	}

int CVICALLBACK Pause (int panel, int control, int event, void *callbackData, int eventData1, int eventData2)
{
	switch (event) {
		case EVENT_COMMIT:
			GetCtrlVal(aph,AP_Pause,&PauseState);
			ResetTextBox (aph, AP_Error,"");  
			break;
	}
	return 0;
}

int CVICALLBACK Pause_FNF (int panel, int control, int event, void *callbackData, int eventData1, int eventData2)
{
	switch (event) {
		case EVENT_COMMIT:
			GetCtrlVal(aph,AP_Pause_FNF,&PauseOnFNF);
			break;
	}
	return 0;
}

int CVICALLBACK Graph_Select (int panel, int control, int event,
		void *callbackData, int eventData1, int eventData2)
{
	switch (event) {
		case EVENT_COMMIT:
			switch (control)
			{
			case AP_GraphSelect1:
					GetCtrlVal(aph,control,&graphsel[0]);				
					break;
			case AP_GraphSelect2:
					GetCtrlVal(aph,control,&graphsel[1]);
					break;
			case AP_GraphSelect3:
					GetCtrlVal(aph,control,&graphsel[2]);
					break;
			case AP_GraphSelect4:
					GetCtrlVal(aph,control,&graphsel[3]);
					break;
			}		
			break;
	}
	return 0;
}

int CVICALLBACK InitParam (int panel, int control, int event, void *callbackData, int eventData1, int eventData2)
{
	switch (event) {
		case EVENT_VAL_CHANGED:
			 switch (control)
			{
			case AP_a1_A:
					GetCtrlVal(aph,AP_a1_A,&coef[3]);
					break;
			case AP_a2_A:
					GetCtrlVal(aph,AP_a2_A,&coef[7]);
					break;
			case AP_a3_A:
					GetCtrlVal(aph,AP_a3_A,&coef[11]);
					break;
			case AP_a4_A:
					GetCtrlVal(aph,AP_a4_A,&coef[15]);
					break;
			case AP_t1_A:
					GetCtrlVal(aph,AP_t1_A,&coef[1]);
					break;
			case AP_t2_A:
					GetCtrlVal(aph,AP_t2_A,&coef[5]);
					break;
			case AP_t3_A:
					GetCtrlVal(aph,AP_t3_A,&coef[9]);
					break;
			case AP_t4_A:
					GetCtrlVal(aph,AP_t4_A,&coef[13]);
					break;
			case AP_w1_A:
					GetCtrlVal(aph,AP_w1_A,&coef[0]);
					break;
			case AP_w2_A:
					GetCtrlVal(aph,AP_w2_A,&coef[4]);
					break;		
			case AP_w3_A:
					GetCtrlVal(aph,AP_w3_A,&coef[8]);
					break;
			case AP_w4_A:
					GetCtrlVal(aph,AP_w4_A,&coef[12]);
					break;		
			case AP_p1_A:
					GetCtrlVal(aph,AP_p1_A,&coef[2]);
					break;
			case AP_p2_A:
					GetCtrlVal(aph,AP_p2_A,&coef[6]);
					break;		
			case AP_p3_A:
					GetCtrlVal(aph,AP_p3_A,&coef[10]);
					break;
			case AP_p4_A:
					GetCtrlVal(aph,AP_p4_A,&coef[14]);
					break;
			case AP_a1_B:
					GetCtrlVal(aph,AP_a1_B,&coef[3]);
					break;
			case AP_a2_B:
					GetCtrlVal(aph,AP_a2_B,&coef[7]);
					break;
			case AP_a3_B:
					GetCtrlVal(aph,AP_a3_B,&coef[11]);
					break;
			case AP_a4_B:
					GetCtrlVal(aph,AP_a4_B,&coef[15]);
					break;
			case AP_t1_B:
					GetCtrlVal(aph,AP_t1_B,&coef[1]);
					break;
			case AP_t2_B:
					GetCtrlVal(aph,AP_t2_B,&coef[5]);
					break;
			case AP_t3_B:
					GetCtrlVal(aph,AP_t3_B,&coef[9]);
					break;
			case AP_t4_B:
					GetCtrlVal(aph,AP_t4_B,&coef[13]);
					break;
			case AP_w1_B:
					GetCtrlVal(aph,AP_w1_B,&coef[0]);
					break;
			case AP_w2_B:
					GetCtrlVal(aph,AP_w2_B,&coef[4]);
					break;		
			case AP_w3_B:
					GetCtrlVal(aph,AP_w3_B,&coef[8]);
					break;
			case AP_w4_B:
					GetCtrlVal(aph,AP_w4_B,&coef[12]);
					break;		
			case AP_p1_B:
					GetCtrlVal(aph,AP_p1_B,&coef[2]);
					break;
			case AP_p2_B:
					GetCtrlVal(aph,AP_p2_B,&coef[6]);
					break;		
			case AP_p3_B:
					GetCtrlVal(aph,AP_p3_B,&coef[10]);
					break;
			case AP_p4_B:
					GetCtrlVal(aph,AP_p4_B,&coef[14]);
					break;		
			
			}		
			break;
	}
	return 0;
}

int CVICALLBACK Names (int panel, int control, int event, void *callbackData, int eventData1, int eventData2)
	{
	switch (event) 
		{
		case EVENT_VAL_CHANGED:
			switch (control) 
				{
				case AP_InputDir:
					GetCtrlVal(aph,AP_InputDir,indir);
					break;
				case AP_InputName:
					GetCtrlVal(aph,AP_InputName,iname);
					ResetTextBox (aph, AP_SumName, iname);
					GetCtrlVal(aph,AP_SumName,sumname);
					break;
				case AP_SerStart:
					GetCtrlVal(aph,AP_SerStart,&serstart);
					sprintf(cumname,"%s%d-.cum",sumname,serstart);
					sprintf(fitname,"%s%d-.fit",sumname,serstart);
					ResetTextBox (aph, AP_CumName, cumname);
					break;
				case AP_SerStop:
					GetCtrlVal(aph,AP_SerStop,&serstop);
					sprintf(cumname,"%s%d-%d.cum",sumname,serstart,serstop);
					sprintf(fitname,"%s%d-%d.fit",sumname,serstart,serstop);
					ResetTextBox (aph, AP_CumName, cumname);
					break;	
				case AP_SerSuffix:
					GetCtrlVal(aph,AP_SerSuffix,sersuffix);
					break;
				case AP_OutputDirCum:
					GetCtrlVal(aph,AP_OutputDirCum,outdircum);
					break;	
				case AP_SumName:
					GetCtrlVal(aph,AP_SumName,sumname);
					break;
				case AP_CumName:
					GetCtrlVal(aph,AP_CumName,cumname);
					break;
				}
			break;
		}
	return 0;
	}

int CVICALLBACK ReadData (int panel, int control, int event, void *callbackData, int eventData1, int eventData2)
	{
	int hdle,cntl,error,size;
	
	switch (event) {
		case EVENT_COMMIT:	
			GetCtrlVal(aph,AP_SerStart,&serstart);
			sprintf (readfilename, "%s%s%d%s", indir,iname,serstart,sersuffix);
			SetCtrlVal(aph,AP_CurNum,serstart);
           	DisableBreakOnLibraryErrors();
		   	error=GetFileSize(readfilename,&size);
            EnableBreakOnLibraryErrors();
          	if (error!=0) {
		   		InstallPopup(fnfh);
		   		GetUserEvent(1, &hdle, &cntl);
		   		RemovePopup(fnfh);  
		   		break;
				}
			if (strcmp(sersuffix,".bin")==0) {
				RawPoints=size/(8*(1+NEWCELLS)); /* was NCELLS */
				filetype=VAL_BINARY;
				}
			else {
				RawPoints=size/(15*(1+NEWCELLS)+2); /* was NCELLS */ 
				filetype=VAL_ASCII;
				}
			FileRead();
			break;
		}
	return 0;
	}

int CVICALLBACK SingleAnalyze (int panel, int control, int event, void *callbackData, int eventData1, int eventData2)
//WCG 030502: moved the main part of this function to AnalyzeFile.
//Seems to run faster if called from within the timer callback?
	{
	int curnum;
	
	switch (event) 
		{
		case EVENT_COMMIT:
		   	GetCtrlVal(aph,AP_CurNum,&curnum);
		   	sernum=curnum;
			SingleON=1;
			break;
		}
	return 0;
	}

int CVICALLBACK SerAnalyze (int panel, int control, int event, void *callbackData, int eventData1, int eventData2)
	{
	int i,error,hdle,cntl,size;
	WriteParamString = 1; //set header flag to write parameters to beginning of new *.cum file
	switch (event) 
		{
		case EVENT_COMMIT:
			sprintf(cumfilename,"%s%s",outdircum,cumname);
           	DisableBreakOnLibraryErrors();
			error=GetFileSize(cumfilename,&size);
			EnableBreakOnLibraryErrors();
			if (error!=-1) 
				{
			   	SetCtrlVal(feh,FE_Error,"Cumulative File Exists");
				SetCtrlAttribute (feh, FE_NewName, ATTR_LABEL_TEXT,"New Cumulative File");
			   	ResetTextBox(feh,FE_NewName,cumname);
			   	InstallPopup(feh);	
		 		GetUserEvent(1, &hdle, &cntl);
  	   			GetCtrlVal(feh,FE_NewName,cumname);
	  			RemovePopup(feh);
	  			if (cntl!=FE_OV) 
					{
	  				sprintf(cumfilename,"%s%s",outdircum,cumname);
	  				DisableBreakOnLibraryErrors();
			  		error=GetFileSize(cumfilename,&size);
			  		EnableBreakOnLibraryErrors();
			  	 	if (error!=-1) break;
			  		}
				}
			sernum=serstart;
			SerON=1;
			break;
		}
	return 0;
	}

static int AnalyzeFile(void) //The highest level analysis function. Calls AnalData, FitData to process data for a single run
	{	
	int error,size,cntl,hdle;
	cntl=0;

	SetCtrlVal(aph,AP_CurNum,sernum);
	sprintf (readfilename, "%s%s%d%s", indir,iname,sernum,sersuffix);
	  			
	DisableBreakOnLibraryErrors();
	error=GetFileSize(readfilename,&size);
	EnableBreakOnLibraryErrors();
           		
	if(error==0 || SingleON) 
		{
		if (!SingleON) 
			{
			if (strcmp(sersuffix,".bin")==0) 
				{
				RawPoints=size/(8*(1+NEWCELLS));	/* was NCELLS */ 
				filetype=VAL_BINARY;
				}
			else 
				{
				RawPoints=size/(15*(1+NEWCELLS)+2);	   /* was NCELLS */ 
				filetype=VAL_ASCII;
				}
			FileRead();
			}
		
		GetCtrlVal(aph,AP_DataStartA,&dstartA);
		GetCtrlVal(aph,AP_DataStopA,&dstopA);
		
		dstart = dstartA; //set time limits for data sample to be fit
		dstop = dstopA;
		
		//AnalData consolidates 2 polarization channels into one channel per cell, and takes the 
		//data sample within relevant limits
		AnalData(sernum, 1);
		ProcessSystemEvents();
	
		dstopA = Rawdata[stopi]; //reassign value to dstop on A period to correspond to shutter close time
		
		sample = 1; //record sample #1
		ProcessSystemEvents();
		
		FitData();//FitData directs the single-cell data fitting routine for all samples   
		ProcessSystemEvents();
		
    	DeleteGraphPlot (aph, AP_AmpDev, -1,VAL_DELAYED_DRAW);
		SetCtrlAttribute (aph, AP_AmpDev, ATTR_REFRESH_GRAPH, 0);
		
		//ProductFit takes the product of 2 cell signal samples (stored in Fitdata[] by AnalData function) 
		//and computes the phase difference between them, along with an associated error bar (note that 
		//the phase differences should be antisymmetric when cell #'s are switched)
		
		ProductFit(0,1);
		ProcessSystemEvents();
		ProductFit(0,2);
		ProcessSystemEvents();
		ProductFit(0,3);
		ProcessSystemEvents();
		ProductFit(1,2);
		ProcessSystemEvents();
		ProductFit(1,3);
		ProcessSystemEvents();
		ProductFit(2,3);
		ProcessSystemEvents();
		
		ProductComboFit(1, 2, 1.0, 3, 4, -0.333333, 0, 0, 0.0, 0); //Run combo phase fit for EDM channel #1 ([MT-MB]-(1/3)[OT-OB])
		ProcessSystemEvents();
		ProductComboFit(1, 2, 0.666666, 1, 3, 0.333333, 2, 4, -0.333333, 1); //Run combo phase fit for EDM channel #2 ((2/3)[MT-MB]+(1/3)[OT-OB]-(1/3)[MB-OB])
		ProcessSystemEvents();
		ProductComboFit(1, 3, -1.0, 2, 4, -1.0, 0, 0, 0.0, 2); //Combo phase fit for Leak Test channel ([OT+OB]-[MT+MB]=(-1)[OT-MT]-[OB-MB])
		ProcessSystemEvents();
		ProductComboFit(1, 2, 0.5, 1, 3, 0.5, 0, 0, 0.0, 3); //Combo phase fit for 3-cell EDM channel #1
		ProcessSystemEvents();
		ProductComboFit(1, 2, 0.5, 2, 4, -0.5, 0, 0, 0.0, 4); //Combo phase fit for 3-cell EDM channel #2
		ProcessSystemEvents();
		
		SetCtrlAttribute (aph, AP_AmpDev, ATTR_REFRESH_GRAPH, 1);
		SetCtrlAttribute (aph, AP_AmpDev, ATTR_ENABLE_ZOOM_AND_PAN, 1);

		if (SingleON) //check for summary file overwriting
			{
			DisableBreakOnLibraryErrors();
			error=GetFileSize(sumfilename,&size);
			EnableBreakOnLibraryErrors();
			if (error!=-1) 
				{
			   	SetCtrlVal(feh,FE_Error,"Summary File Exists");
				SetCtrlAttribute (feh, FE_NewName, ATTR_LABEL_TEXT,"New Summary File");
			   	ResetTextBox(feh,FE_NewName,sumfilename);
			   	InstallPopup(feh);	
		 		do 
					{
		 			GetUserEvent(1, &hdle, &cntl);
  	   				GetCtrlVal(feh,FE_NewName,sumfilename);
			   		} while (cntl!=FE_OV && cntl!=FE_Cancel);
			   	RemovePopup(feh);
				}
			//if (cntl!=FE_Cancel) WriteSum();
			}
		else 
			{ 
			//WriteSum();
			ProcessSystemEvents();
			AddCum();
			}
		
		GetCtrlVal(aph,AP_DataStartB,&dstartB);
		GetCtrlVal(aph,AP_DataStopB,&dstopB);
		
		dstart = dstartB; //set time limits for data sample to be fit
		dstop = dstopB;
		
		//AnalData consolidates 2 polarization channels into one channel per cell, and takes the 
		//data sample within relevant limits
		AnalData(sernum, 2);
		ProcessSystemEvents();
		
		dstartB = Rawdata[starti]; //reassign value of dstart on B period to correspond to shutter open time
		
		sample = 2;
		ProcessSystemEvents();
		
		FitData();
		ProcessSystemEvents();
		
		DeleteGraphPlot (aph, AP_AmpDev2, -1,VAL_DELAYED_DRAW);
		SetCtrlAttribute (aph, AP_AmpDev2, ATTR_REFRESH_GRAPH, 0);
		
 		ProductFit(0,1);
		ProcessSystemEvents();
		ProductFit(0,2);
		ProcessSystemEvents();
		ProductFit(0,3);
		ProcessSystemEvents();
		ProductFit(1,2);
		ProcessSystemEvents();
		ProductFit(1,3);
		ProcessSystemEvents();
		ProductFit(2,3);
		ProcessSystemEvents();
		
		TDark1=(dstartB-dstopA)/log(AmpA1/AmpB1);
		TDark2=(dstartB-dstopA)/log(AmpA2/AmpB2); 
		TDark3=(dstartB-dstopA)/log(AmpA3/AmpB3); 
		TDark4=(dstartB-dstopA)/log(AmpA4/AmpB4); 
		
		ProductComboFit(1, 2, 1.0, 3, 4, -0.333333, 0, 0, 0.0, 0); //Run combo phase fit for EDM channel #1 ([MT-MB]-(1/3)[OT-OB])
		ProcessSystemEvents();
		ProductComboFit(1, 2, 0.666666, 1, 3, 0.333333, 2, 4, -0.333333, 1); //Run combo phase fit for EDM channel #2 ((2/3)[MT-MB]+(1/3)[OT-OB]-(1/3)[MB-OB])
		ProcessSystemEvents();
		ProductComboFit(1, 3, -1.0, 2, 4, -1.0, 0, 0, 0.0, 2); //Combo phase fit for Leak Test channel ([OT+OB]-[MT+MB]=(-1)[OT-MT]-[OB-MB])
		ProcessSystemEvents();
		ProductComboFit(1, 2, 0.5, 1, 3, 0.5, 0, 0, 0.0, 3); //Combo phase fit for 3-cell EDM channel #1
		ProcessSystemEvents();
		ProductComboFit(1, 2, 0.5, 2, 4, -0.5, 0, 0, 0.0, 4); //Combo phase fit for 3-cell EDM channel #2
		ProcessSystemEvents();
		
		SetCtrlAttribute (aph, AP_AmpDev2, ATTR_REFRESH_GRAPH, 1);
   		SetCtrlAttribute (aph, AP_AmpDev2, ATTR_ENABLE_ZOOM_AND_PAN, 1); 
		
		if(!SingleON) AddCum(); //write out results of fits to *.cum file
		}
	else if (PauseOnFNF) 
		{
		PauseState=1;
		SetCtrlVal(aph,AP_Pause,Pause);
		ResetTextBox (aph, AP_Error,"File Not Found!");
	 	}
	return 0;
	}

int CVICALLBACK TimerCallback (int panel, int control, int event, void *callbackData, int eventData1, int eventData2)
	{
	int error,size;

    switch (event) 
		{
        case EVENT_TIMER_TICK:	
        	if (SerON&&!PauseState) 
				{
        		if (sernum<=serstop) 
					{
					AnalyzeFile();
					sernum=sernum+1;
					}
				else SerON=0;	
				}
			else if (Pick_Up && !PauseState) //if running in "Pick Up Data" mode && program is not paused
				{
				sprintf (readfilename, "%s%s%d%s", indir,iname,sernum,sersuffix);
				DisableBreakOnLibraryErrors();
				error=GetFileSize(readfilename,&size); //check to see that the file exists
				EnableBreakOnLibraryErrors();
				if (error==0) 
					{
					Delay (1.0); //add 1.0 second delay before reading a binary file, to ensure EDM_ACQ has time to finish writing
					if ((oldsize==size)&&(size>0)) 
						{
						AnalyzeFile();
						sernum=sernum+1;
						}
					else  oldsize=size;
					}	
				}
			else if (SingleON) 
				{
				AnalyzeFile();
				SingleON=0;
				}
			break;
			}
	return 0;
	}

int CVICALLBACK Pickup (int panel, int control, int event, void *callbackData, int eventData1, int eventData2)
	{
	int error,size,hdle,cntl;
	
	switch (event) 
		{
		case EVENT_COMMIT:
		GetCtrlVal(aph,AP_Pickup,&Pick_Up);
		if(Pick_Up) 
			{
			sprintf(cumfilename,"%s%s",outdircum,cumname);
			DisableBreakOnLibraryErrors();
			error=GetFileSize(cumfilename,&size);
			EnableBreakOnLibraryErrors();
			if (error!=-1) 
				{
			   	SetCtrlVal(feh,FE_Error,"Cummulative File Exists");
				SetCtrlAttribute (feh, FE_NewName, ATTR_LABEL_TEXT,"New Cumulative File");
			   	ResetTextBox(feh,FE_NewName,cumname);
			   	InstallPopup(feh);	
		 		GetUserEvent(1, &hdle, &cntl);
  	   			GetCtrlVal(feh,FE_NewName,cumname);
	  			RemovePopup(feh);
	  			if (cntl!=FE_OV) 
					{
	  				sprintf(cumfilename,"%s%s",outdircum,cumname);
	  				DisableBreakOnLibraryErrors();
			  		error=GetFileSize(cumfilename,&size);
			  		EnableBreakOnLibraryErrors();
			  	 	if (error!=-1) break;
			  		}
				}
			sernum=serstart;
			}
		break;
		}
	return 0;
	}

static int FileRead(void)
	{
	int i,j,rawpoints_estimate=RawPoints;
	double ave, spacing;

	SetCtrlVal(aph,AP_Ind,1);
	Rawdata=realloc (Rawdata,(1+NEWCELLS)*RawPoints*sizeof(double));	   /* was NCELLS */ 

	//Read in the raw data from the relevant *.bin file
	FileToArray (readfilename,Rawdata,VAL_DOUBLE,(1+NEWCELLS)*RawPoints,1+NEWCELLS,VAL_GROUPS_TOGETHER,VAL_GROUPS_AS_COLUMNS,VAL_BINARY);
	
	spacing=Rawdata[1]-Rawdata[0];

    //graph the raw data read in from file-one plot for each cell (i.e., each odd-numbered data array)
	DeleteGraphPlot  (aph, AP_Data, -1,VAL_DELAYED_DRAW);
    SetCtrlAttribute (aph, AP_Data, ATTR_REFRESH_GRAPH, 0);
   	DeleteGraphPlot  (aph, AP_Data2, -1,VAL_DELAYED_DRAW);
    SetCtrlAttribute (aph, AP_Data2, ATTR_REFRESH_GRAPH, 0);
	
	for (i=0; i<NCELLS; i++) 
		{		
    	if (graphsel[i]==1) 
			{
       		PlotXY (aph, AP_Data,&Rawdata[0], &Rawdata[RawPoints*(2*i+1)],
       		RawPoints,VAL_DOUBLE, VAL_DOUBLE, VAL_THIN_LINE, VAL_EMPTY_SQUARE,
       		VAL_SOLID, 1, ColorArray[i]);
       		}
       	else 
			{
       		PlotXY (aph, AP_Data2,&Rawdata[0], &Rawdata[RawPoints*(2*i+1)],
       		RawPoints,VAL_DOUBLE, VAL_DOUBLE, VAL_THIN_LINE, VAL_EMPTY_SQUARE,
       		VAL_SOLID, 1, ColorArray[i]);
       		}
    	}
            
    SetCtrlAttribute (aph, AP_Data, ATTR_REFRESH_GRAPH, 1);	
    SetCtrlAttribute (aph, AP_Data, ATTR_ENABLE_ZOOM_AND_PAN, 1);
    SetCtrlAttribute (aph, AP_Data2, ATTR_REFRESH_GRAPH, 1);	
    SetCtrlAttribute (aph, AP_Data2, ATTR_ENABLE_ZOOM_AND_PAN, 1);
    
	Mean(&Rawdata[RawPoints], RawPoints, &ave);
    previousBOLEstate = GetBreakOnLibraryErrors ();
	
	SetCtrlAttribute (aph, AP_Data, ATTR_NUM_CURSORS, 4);
	SetCtrlAttribute (aph, AP_Data2, ATTR_NUM_CURSORS, 4);

	//display cursors on graphs of raw data indicating data periods to be analyzed
	if (previousBOLEstate) DisableBreakOnLibraryErrors();
	SetGraphCursor (aph, AP_Data, 1, dstartA, ave); 
    SetGraphCursor (aph, AP_Data, 2, dstopA, ave);
	SetGraphCursor (aph, AP_Data, 3, dstartB, ave); 
    SetGraphCursor (aph, AP_Data, 4, dstopB, ave);
    SetGraphCursor (aph, AP_Data2, 1, dstartA, ave); 
    SetGraphCursor (aph, AP_Data2, 2, dstopA, ave);
	SetGraphCursor (aph, AP_Data2, 3, dstartB, ave); 
    SetGraphCursor (aph, AP_Data2, 4, dstopB, ave);
	if (previousBOLEstate) EnableBreakOnLibraryErrors();
    
    return 0;
	}

static int AnalData(int filenum, int sample) //handles data linearization, filtering, and channel set selection
	{ 
	int error,i,j,k,p;
	int startave=0,step;
  	double ave,time,bc,transavetime=30.0;
	double *Filterdata = 0;
    double ep, omep, q, Den, dT;
    double fac3,fac2;
    double Pi=3.1415926535897932384; 
    double Dev1, Dev2, Dev3, Dev4, Dev5, Dev6, Dev7, Dev8;
	double MeanV1, MeanV2, MeanV3, MeanV4, MeanV5, MeanV6, MeanV7, MeanV8;
	double D1, D2, D3, D4, D5, D6, D7, D8;
	double rawDataSum[RawPoints];
	double a0,a1,a2,b1,b2; //Chebyshev recursive filter coefficients
	static double *Wa; Wa = malloc((FitPoints-12)*sizeof(double));
	static double *Wb; Wb = malloc((FitPoints-12)*sizeof(double));

	Filterdata = malloc((1+NCELLS)*sizeof(double));
	
	starti = 0;
	stopi = 0;
	pumpPts = 0;
	
	SetCtrlVal(aph,AP_Ind,2); //set status bar to "Filter"  
	for (i=0;i<RawPoints; i++) //loop over all Raw Points to get time values, number of points to be analyzed
		{
		rawDataSum[i] = Rawdata[RawPoints*1 + i] + Rawdata[RawPoints*2 + i] +
			 			Rawdata[RawPoints*3 + i] + Rawdata[RawPoints*4 + i] +
						Rawdata[RawPoints*5 + i] + Rawdata[RawPoints*6 + i] +
						Rawdata[RawPoints*7 + i] + Rawdata[RawPoints*8 + i];
   		if(Rawdata[i]<dstart) starti++; //find the start index in RawPoints array
   		if(Rawdata[i]<(dstop-transavetime)) ++startave; //index for finding transmission average only from last 30 seconds
   		if(Rawdata[i]<dstop)  stopi++; //find the stop index in RawPoints
		}
	
	if (sample == 1)  //initialize sample shutter open, close values for Tdiff measurements with small analysis window
		{
		shutterOpenA = Rawdata[starti]; 
		shutterCloseA = Rawdata[stopi]; //shutterCloseA is used to calcluate dark time for Tdiff analysis-should be 50 ms before the shutter closes
		}
	if (sample == 2)
		{
		shutterOpenB = Rawdata[starti]; //shutterOpenB should correspond to the beginning of the data train, set 50 ms after the shutter opens
		shutterCloseB = Rawdata[stopi];
		}
	
	for (j=0; j<5000; j++) //loop over data to identify actual shutter open, close times
		{
		if (rawDataSum[starti-j] > 1.0 && rawDataSum[starti-(j+1)] < 1.0)  //check to see if the 1V threshold was crossed between 2 adjacent points
			{
			if (sample == 1) 
				{
				//shutterOpenA = Rawdata[starti-j];
				for (i=0; i<starti-j; i++) //loop over data points prior to shutterOpen to calculate total light on time during pump phase
					{
					if(rawDataSum[i] > 1.0) pumpPts++;
					}
				SetCtrlVal(aph,AP_PumpPoints,pumpPts); //output total # of points w/ light on during pump time
				}
			else if (sample == 2)  
				{
				shutterOpenB = Rawdata[starti-j+10]; //record time for output to *.cum file 
				starti += 10-j; //redefine index for beginning of data analysis on sample 2 - 50ms from shutter opening
				//AnalPoints = stopi - starti; //calculate number of points to analyze 
				}
			j = 5000; //break out of j loop
			}
		}
	
	if (sample == 1)
		{
		for (j=0; j<500; j++)
			{
			if (rawDataSum[stopi+j] > 1.0 && rawDataSum[stopi+j+1] < 1.0)
				{
				shutterCloseA = Rawdata[stopi+j-10];
				stopi += j-10;  //index for end of data train in period A
				//AnalPoints = stopi - starti; //calculate number of points to analyze 
				j = 500; //break out of j loop
				}
			}
		}

	AnalPoints = stopi - starti; //number of points to be analyzed
	Analdata = realloc(Analdata,(1+NEWCELLS)*AnalPoints*sizeof(double));	//was NCELLS
	
	for (i=0;i<AnalPoints; i++) //assign time values to the first block (size AnalPoints) in Analdata
		{
		//Analdata[i]=Rawdata[i+starti]-Rawdata[starti]; //get time values for analysis points
		Analdata[i]=Rawdata[i+starti];
		}
	
	time=Analdata[AnalPoints-1];

	for (i=0; i<NEWCELLS; i++) /* was NCELLS */ 
		{
		for (j=0;j<AnalPoints;j++) //write Rawdata into Analdata
		//i loops over cells, j loops over time values in each cell signal
			{
			//starti+j is the time index referenced to the beginning of the .bin file (start of pumping)
			Analdata[AnalPoints*(1+i)+j] = Rawdata[RawPoints*(i+1) + starti + j];
			}
		}
	
   	DeleteGraphPlot  (aph, AP_Data, -1,VAL_DELAYED_DRAW);
    SetCtrlAttribute (aph, AP_Data, ATTR_REFRESH_GRAPH, 0);
	SetCtrlAttribute (aph, AP_Data, ATTR_REFRESH_GRAPH, 1); 
	SetCtrlAttribute (aph, AP_Data, ATTR_ENABLE_ZOOM_AND_PAN, 1);
   	
	DeleteGraphPlot  (aph, AP_Data2, -1,VAL_DELAYED_DRAW);
    SetCtrlAttribute (aph, AP_Data2, ATTR_REFRESH_GRAPH, 0);
    SetCtrlAttribute (aph, AP_Data2, ATTR_REFRESH_GRAPH, 1);
    SetCtrlAttribute (aph, AP_Data2, ATTR_ENABLE_ZOOM_AND_PAN, 1);

	Analdata0=realloc (Analdata0,AnalPoints*sizeof(double));
    Analdata1=realloc (Analdata1,AnalPoints*sizeof(double));
	Analdata2=realloc (Analdata2,AnalPoints*sizeof(double));  
	Analdata3=realloc (Analdata3,AnalPoints*sizeof(double));
	Analdata4=realloc (Analdata4,AnalPoints*sizeof(double)); 
	Analdata5=realloc (Analdata5,AnalPoints*sizeof(double));
    Analdata6=realloc (Analdata6,AnalPoints*sizeof(double));
	Analdata7=realloc (Analdata7,AnalPoints*sizeof(double));  
	Analdata8=realloc (Analdata8,AnalPoints*sizeof(double));
	AnaldataS=realloc (AnaldataS,AnalPoints*sizeof(double));       

	Subset1D(Analdata, 9*AnalPoints, 0*AnalPoints, AnalPoints, Analdata0);
	Subset1D(Analdata, 9*AnalPoints, 1*AnalPoints, AnalPoints, Analdata1);
	Subset1D(Analdata, 9*AnalPoints, 2*AnalPoints, AnalPoints, Analdata2);  
	Subset1D(Analdata, 9*AnalPoints, 3*AnalPoints, AnalPoints, Analdata3);
	Subset1D(Analdata, 9*AnalPoints, 4*AnalPoints, AnalPoints, Analdata4);
	Subset1D(Analdata, 9*AnalPoints, 5*AnalPoints, AnalPoints, Analdata5);
	Subset1D(Analdata, 9*AnalPoints, 6*AnalPoints, AnalPoints, Analdata6);  
	Subset1D(Analdata, 9*AnalPoints, 7*AnalPoints, AnalPoints, Analdata7);
	Subset1D(Analdata, 9*AnalPoints, 8*AnalPoints, AnalPoints, Analdata8);

	/*
	//Monte Carlo data simulation: Overwrite data arrays 
	//Optimal frequency for phase-shift T[] array calc = 52.3598775
	dT = 500.0 + (0.2 * rand()/(double)RAND_MAX);
	GaussNoise (AnalPoints, 2.5E-05 * 1.0/(sample*1.0), -1, AnaldataS);
	
	//Unmodulated squared sine wave at ideal filter frequency for all cells  
	//for (i=0;i<AnalPoints;i++) 
	//	{
	//	Analdata1[i] = 4 + 3.5 * sin(1.5*sin(52.3588775 * Analdata0[i]) * exp(-1.0*Analdata0[i]/dT-1.0*i/(AnalPoints*4))*exp(-1.0*(sample-1)*shutterOpenB/500)) + AnaldataS[i];
	//	Analdata1[i] +=  Analdata1[i] * Analdata1[i];
	//	}
	
	//Unmodulated sine wave at ideal filter frequency
	//for (i=0;i<AnalPoints;i++) Analdata1[i] = 4 + 3.5 * sin(52.3589 * Analdata0[i]) * exp(-1.0*Analdata0[i]/dT-1.0*i/(AnalPoints*4))*exp(-1.0*(sample-1)*shutterOpenB/500) + AnaldataS[i];

	//Frequency modulated sine wave at ideal filter frequency for all cells
	for (i=0;i<AnalPoints;i++) Analdata1[i] = 4 + 3.5 * sin(52.359 * Analdata0[i] + 0.00035 * sin(311.1 * Analdata0[i])) * exp(-1.0*Analdata0[i]/dT-1.0*i/(AnalPoints*4))*exp(-1.0*(sample-1)*shutterOpenB/500) + AnaldataS[i];

	GaussNoise (AnalPoints, 2.5E-05 * 1.0/(sample*1.0), -1, AnaldataS);				  

	//Unmodulated squared sine wave at ideal filter frequency for all cells  
	//for (i=0;i<AnalPoints;i++) 
	//	{
	//	Analdata2[i] = 4 + 3.5 * sin(1.5*sin(52.3588775 * Analdata0[i] + Pi) * exp(-1.0*Analdata0[i]/dT-1.0*i/(AnalPoints*4))*exp(-1.0*(sample-1)*shutterOpenB/500)) + AnaldataS[i];  
	//	Analdata2[i] +=  Analdata2[i] * Analdata2[i];
	//	}
	
	//Unmodulated sine wave at ideal filter frequency
	//for (i=0;i<AnalPoints;i++) Analdata2[i] = 4 + 3.5 * sin((52.3589 * Analdata0[i]) + Pi) * exp(-1.0*Analdata0[i]/dT-1.0*i/(AnalPoints*4))*exp(-1.0*(sample-1)*shutterOpenB/500) + AnaldataS[i];
	
	//Frequency modulated sine wave at ideal filter frequency for middle cells 
	for (i=0;i<AnalPoints;i++) Analdata2[i] = 4 + 3.5 * sin((52.359 * Analdata0[i] + 0.00035 * sin(311.1 * Analdata0[i])) + Pi) * exp(-1.0*Analdata0[i]/dT-1.0*i/(AnalPoints*4))*exp(-1.0*(sample-1)*shutterOpenB/500) + AnaldataS[i];
	//for (i=0;i<AnalPoints;i++) Analdata2[i] = 4 + 3.5 * sin(52.359 * Analdata0[i] + Pi) * exp(-1.0*Analdata0[i]/dT-1.0*i/(AnalPoints*4))*exp(-1.0*(sample-1)*shutterOpenB/500) + AnaldataS[i];


	dT = 400.0 + (0.2 * rand()/(double)RAND_MAX); 
	GaussNoise (AnalPoints, 2.5E-05 * 1.0/(sample*1.0), -1, AnaldataS);
	
	//Unmodulated squared sine wave at ideal filter frequency for all cells  
	//for (i=0;i<AnalPoints;i++) Analdata3[i] = 4 + 3.5 * sin(1.5*sin(52.3588775 * Analdata0[i]) * exp(-1.0*Analdata0[i]/dT-1.0*i/(AnalPoints*4))*exp(-1.0*(sample-1)*shutterOpenB/500)) + AnaldataS[i];

	//Unmodulated sine wave at ideal filter frequency 
	//for (i=0;i<AnalPoints;i++) 
	//	{
	//	Analdata3[i] = 4 + 3.3 * sin(52.359 * Analdata0[i]) * exp(-1.0*Analdata0[i]/dT-1.0*i/(AnalPoints*4))*exp(-1.0*(sample-1)*shutterOpenB/500) + AnaldataS[i];
	//  Analdata7[i] = Analdata3[i];
	//	}

	//Frequency modulated sine wave at ideal filter frequency for middle cells 
	for (i=0;i<AnalPoints;i++) Analdata3[i] = 4 + 3.3 * sin(52.3589 * Analdata0[i] - 0.00033 * sin(311.1 * Analdata0[i] + Pi)) * exp(-1.0*Analdata0[i]/dT-1.0*i/(AnalPoints*4))*exp(-1.0*(sample-1)*shutterOpenB/500) + AnaldataS[i];

	GaussNoise (AnalPoints, 2.5E-05 * 1.0/(sample*1.0), -1, AnaldataS);

	//Unmodulated squared sine wave at ideal filter frequency for all cells
	//for (i=0;i<AnalPoints;i++) Analdata4[i] = 4 + 3.5 * sin(1.5*sin(52.3588775 * Analdata0[i] + Pi) * exp(-1.0*Analdata0[i]/dT-1.0*i/(AnalPoints*4))*exp(-1.0*(sample-1)*shutterOpenB/500)) + AnaldataS[i];  

	//Unmodulated sine wave at ideal filter frequency
	//for (i=0;i<AnalPoints;i++) 
	//	{
	//	Analdata4[i] = 4 + 3.3 * sin((52.359 * Analdata0[i]) + Pi) * exp(-1.0*Analdata0[i]/dT-1.0*i/(AnalPoints*4))*exp(-1.0*(sample-1)*shutterOpenB/500) + AnaldataS[i];
	//  Analdata8[i] = Analdata4[i];
	//	}
	
	//Frequency modulated sine wave at ideal filter frequency for middle cells 
	for (i=0;i<AnalPoints;i++) Analdata4[i] = 4 + 3.3 * sin((52.3589 * Analdata0[i] - 0.00033 * sin(311.1 * Analdata0[i] + Pi)) + Pi) * exp(-1.0*Analdata0[i]/dT-1.0*i/(AnalPoints*4))*exp(-1.0*(sample-1)*shutterOpenB/500) + AnaldataS[i];
	//for (i=0;i<AnalPoints;i++) Analdata4[i] = 4 + 3.3 * sin(52.3589 * Analdata0[i] + Pi) * exp(-1.0*Analdata0[i]/dT-1.0*i/(AnalPoints*4))*exp(-1.0*(sample-1)*shutterOpenB/500) + AnaldataS[i];

	dT = 300.0 + (0.2 * rand()/(double)RAND_MAX); 
	
	GaussNoise (AnalPoints, 2.5E-05 * 1.0/(sample*1.0), -1, AnaldataS);
	for (i=0;i<AnalPoints;i++) Analdata5[i] = 4 + 3.0 * sin(52.3589 * Analdata0[i]) * exp(-1.0*Analdata0[i]/dT-1.0*i/(AnalPoints*4))*exp(-1.0*(sample-1)*shutterOpenB/500) + AnaldataS[i];
							 //Analdata1[i] = 4 + 3.5 * sin(52.3589 * Analdata0[i]) * exp(-1.0*Analdata0[i]/dT-1.0*i/(AnalPoints*4))*exp(-1.0*(sample-1)*shutterOpenB/500) + AnaldataS[i];

	GaussNoise (AnalPoints, 2.5E-05 * 1.0/(sample*1.0), -1, AnaldataS);
	for (i=0;i<AnalPoints;i++) Analdata6[i] = 4 + 3.0 * sin((52.3589 * Analdata0[i]) + Pi) * exp(-1.0*Analdata0[i]/dT-1.0*i/(AnalPoints*4))*exp(-1.0*(sample-1)*shutterOpenB/500) + AnaldataS[i];
							 //Analdata4[i] = 4 + 3.3 * sin((52.3589 * Analdata0[i]) + Pi) * exp(-1.0*Analdata0[i]/dT-1.0*i/(AnalPoints*4))*exp(-1.0*(sample-1)*shutterOpenB/500) + AnaldataS[i];
	
	dT = 200.0 + (0.2 * rand()/(double)RAND_MAX); 
	
	GaussNoise (AnalPoints, 2.5E-05 * 1.0/(sample*1.0), -1, AnaldataS);
	for (i=0;i<AnalPoints;i++) Analdata7[i] = 4 + 2.5 * sin(52.3589 * Analdata0[i]) * exp(-1.0*Analdata0[i]/dT-1.0*i/(AnalPoints*4))*exp(-1.0*(sample-1)*shutterOpenB/500) + AnaldataS[i];
					   	     //Analdata1[i] = 4 + 3.5 * sin(52.359 * Analdata0[i]) * exp(-1.0*Analdata0[i]/dT-1.0*i/(AnalPoints*4))*exp(-1.0*(sample-1)*shutterOpenB/500) + AnaldataS[i];

	GaussNoise (AnalPoints, 2.5E-05 * 1.0/(sample*1.0), -1, AnaldataS);
	for (i=0;i<AnalPoints;i++) Analdata8[i] = 4 + 2.5 * sin((52.3589 * Analdata0[i]) + Pi) * exp(-1.0*Analdata0[i]/dT-1.0*i/(AnalPoints*4))*exp(-1.0*(sample-1)*shutterOpenB/500) + AnaldataS[i];
							 //Analdata4[i] = 4 + 3.3 * sin((52.359 * Analdata0[i]) + Pi) * exp(-1.0*Analdata0[i]/dT-1.0*i/(AnalPoints*4))*exp(-1.0*(sample-1)*shutterOpenB/500) + AnaldataS[i];
	*/
		
		
	StdDev (Analdata1, AnalPoints, &MeanV1, &Dev1);
	StdDev (Analdata2, AnalPoints, &MeanV2, &Dev2);
	StdDev (Analdata3, AnalPoints, &MeanV3, &Dev3);
	StdDev (Analdata4, AnalPoints, &MeanV4, &Dev4);
	StdDev (Analdata5, AnalPoints, &MeanV5, &Dev5);
	StdDev (Analdata6, AnalPoints, &MeanV6, &Dev6);
	StdDev (Analdata7, AnalPoints, &MeanV7, &Dev7);
	StdDev (Analdata8, AnalPoints, &MeanV8, &Dev8);
	
	if (DataSeFlag==0) /* for odd channels alone */ 
		{	
		for (i=0;i<AnalPoints;i++) ////write data from ch 1,3,5,7 to Analdata for analysis 
			{
			Analdata[1*AnalPoints+i]= (Analdata1[i]-2.03)*exp(-1.0*Analdata0[i]/500.);	   // for fake data with Stanford func. gen.
			Analdata[2*AnalPoints+i]= (Analdata3[i]-2.03)*exp(-1.0*Analdata0[i]/500.);
			Analdata[3*AnalPoints+i]= (Analdata5[i]-2.03)*exp(-1.0*Analdata0[i]/500.);
			Analdata[4*AnalPoints+i]= (Analdata7[i]-2.03)*exp(-1.0*Analdata0[i]/500.);
			
			//Analdata[1*AnalPoints+i]= Analdata1[i];
			//Analdata[2*AnalPoints+i]= Analdata3[i];
			//Analdata[3*AnalPoints+i]= Analdata5[i];
			//Analdata[4*AnalPoints+i]= Analdata7[i];
			}
			
		
		mean[4*(sample-1)+0]=MeanV1; //the values of mean[] will determine the values output as Transmission[1...4]   
		mean[4*(sample-1)+1]=MeanV3;
		mean[4*(sample-1)+2]=MeanV5;
		mean[4*(sample-1)+3]=MeanV7;
		}
	
	else if (DataSeFlag==1) /* for even channels only */
		{
		for (i=0;i<AnalPoints;i++) //write data from ch 2,4,6,8 to Analdata for analysis
			{
			Analdata[1*AnalPoints+i]= Analdata2[i];
			Analdata[2*AnalPoints+i]= Analdata4[i];
			Analdata[3*AnalPoints+i]= Analdata6[i];
			Analdata[4*AnalPoints+i]= Analdata8[i];
			}
			
		mean[4*(sample-1)+0]=MeanV2; //the values of mean[] will determine the values output as Transmission[1...4]   
		mean[4*(sample-1)+1]=MeanV4;
		mean[4*(sample-1)+2]=MeanV6;
		mean[4*(sample-1)+3]=MeanV8;
		}
			
	else /* for diff or diff/sum  */
		{
		D1 = Dev1/Dev2;
		D2 = Dev2/Dev1;
		D3 = Dev3/Dev4;
		D4 = Dev4/Dev3;
		D5 = Dev5/Dev6;
		D6 = Dev6/Dev5;
		D7 = Dev7/Dev8;
		D8 = Dev8/Dev7;
	
		mean[4*(sample-1)+0] = (MeanV1 + MeanV2); //Analdata1 is (ch0-ch1)/(ch0+ch1) , ...
		mean[4*(sample-1)+1] = (MeanV3 + MeanV4); //the values of mean[1,3,5,7] are normalized  
		mean[4*(sample-1)+2] = (MeanV5 + MeanV6); //to mean[2,4,6,8] and added to get the sum of
		mean[4*(sample-1)+3] = (MeanV7 + MeanV8); //intensity in the 2 polariztion states.
		
		//Normalize the smaller-amplitude channel for each cell to the larger one 
		if (D1 >= D2)     for (i=0;i<AnalPoints;i++) Analdata2[i] = D1 * Analdata2[i];
		else if (D2 > D1) for (i=0;i<AnalPoints;i++) Analdata1[i] = D2 * Analdata1[i];
		
		if (D3 >= D4)     for (i=0;i<AnalPoints;i++) Analdata4[i] = D3 * Analdata4[i];
		else if (D4 > D3) for (i=0;i<AnalPoints;i++) Analdata3[i] = D4 * Analdata3[i];
		
		if (D5 >= D6)     for (i=0;i<AnalPoints;i++) Analdata6[i] = D5 * Analdata6[i];
		else if (D6 > D5) for (i=0;i<AnalPoints;i++) Analdata5[i] = D6 * Analdata5[i];
		
		if (D7 >= D8)     for (i=0;i<AnalPoints;i++) Analdata8[i] = D7 * Analdata8[i];
		else if (D8 > D7) for (i=0;i<AnalPoints;i++) Analdata7[i] = D8 * Analdata7[i];
		
		//cell 1 in analdata1: 
	    Add1D(Analdata1, Analdata2, AnalPoints, AnaldataS);	 	  
		Sub1D(Analdata1, Analdata2, AnalPoints, Analdata1);
		Div1D(Analdata1, AnaldataS, AnalPoints, Analdata1); 
	
		//cell 2 in analdata3:
		Add1D(Analdata3, Analdata4, AnalPoints, AnaldataS);	 	  
		Sub1D(Analdata3, Analdata4, AnalPoints, Analdata3);
		Div1D(Analdata3, AnaldataS, AnalPoints, Analdata3); 
	 
		//cell 3 in analdata5:
		Add1D(Analdata5, Analdata6, AnalPoints, AnaldataS);	 	  
		Sub1D(Analdata5, Analdata6, AnalPoints, Analdata5);
		Div1D(Analdata5, AnaldataS, AnalPoints, Analdata5); 
		  
		//cell 4 in analdata7:
		Add1D(Analdata7, Analdata8, AnalPoints, AnaldataS);	 	  
		Sub1D(Analdata7, Analdata8, AnalPoints, Analdata7);
		Div1D(Analdata7, AnaldataS, AnalPoints, Analdata7);
		
		
		for (j=0;j<AnalPoints;j++) //write normalized data from odd-numbered channels back into Analdata for analysis
			{
			Analdata[1*AnalPoints+j] = Analdata1[j];
			Analdata[2*AnalPoints+j] = Analdata3[j];
			Analdata[3*AnalPoints+j] = Analdata5[j];
			Analdata[4*AnalPoints+j] = Analdata7[j];
			}
		
		
/////////////////////////////// Average polarization rotation angle algorithm: ///////////////////////////////////
//////////////////////////// Computes avg. polarization angle over a probe period  ///////////////////////////////
//////////////////////// to look for possible correlations w/ frequency difference data //////////////////////////

	   /* 
		Div1D(Analdata1, Analdata2, AnalPoints, Analdata1); 
		Div1D(Analdata3, Analdata4, AnalPoints, Analdata3);
		Div1D(Analdata5, Analdata6, AnalPoints, Analdata5);
		Div1D(Analdata7, Analdata8, AnalPoints, Analdata7);
		
		for (j=0;j<AnalPoints;j++) //calculate polarization rotation angle from  from odd-numbered data channels
			{
			Analdata1[j] = atan(sqrt(Analdata1[j]));
			Analdata3[j] = atan(sqrt(Analdata3[j]));
			Analdata5[j] = atan(sqrt(Analdata5[j]));
			Analdata7[j] = atan(sqrt(Analdata7[j]));
			}
		
		//calculate naive average polarization rotation angles for output as transmission data	
		StdDev (Analdata1, AnalPoints, &MeanV1, &Dev1);
		StdDev (Analdata3, AnalPoints, &MeanV3, &Dev3);
		StdDev (Analdata5, AnalPoints, &MeanV5, &Dev5);
		StdDev (Analdata7, AnalPoints, &MeanV7, &Dev7);
		
		mean[4*(sample-1)+0] = MeanV1;
		mean[4*(sample-1)+1] = MeanV3;
		mean[4*(sample-1)+2] = MeanV5;
		mean[4*(sample-1)+3] = MeanV7;
		
		for (j=0;j<AnalPoints;j++) //write polarization rotation data back into Analdata for analysis  
			{
			Analdata[1*AnalPoints+j] = Analdata1[j];
			Analdata[2*AnalPoints+j] = Analdata3[j];
			Analdata[3*AnalPoints+j] = Analdata5[j];
			Analdata[4*AnalPoints+j] = Analdata7[j];
			}
		*/
		}  //end of else() /* for diff or diff/sum  */ 
	
	for (i=0; i<NCELLS; i++) //plot the data to be analyzed; one trace for each cell (i.e. each odd-numbered channel)
		{		
    	if (graphsel[i]==1) 
			{
       		PlotXY (aph, AP_Data,&Analdata[0], &Analdata[AnalPoints*(i+1)],
       		AnalPoints,VAL_DOUBLE, VAL_DOUBLE, VAL_THIN_LINE, VAL_EMPTY_SQUARE,
       		VAL_SOLID, 1, ColorArray[i]);
       		}
       	else 
			{
       		PlotXY (aph, AP_Data2,&Analdata[0], &Analdata[AnalPoints*(i+1)],
       		AnalPoints,VAL_DOUBLE, VAL_DOUBLE, VAL_THIN_LINE, VAL_EMPTY_SQUARE,
       		VAL_SOLID, 1, ColorArray[i]);
       		}
    	}

//Digital filtering: run data through filter for harmonics of signal frequency, and write the 
//result into Fitdata[] (for nonlinear LM fitting) and S[][] (for ProductFit) 
	if (om>90)
		{
		//om=102.911;
		ep=2.*Pi/(12.*om)-0.005;    
		omep=om*ep;
		q=sqrt(3.)*(cos(4.*omep)-cos(8.*omep))/2.+(sin(4.*omep)+sin(8.*omep))/2;
		Den=sin(6.*omep)*sin(6.*omep)+cos(9.*omep)*(sqrt(3.)*cos(4.*omep)/2.+sin(4.*omep)/2.);
		
		fac2=(sin(6.*omep)*sin(6.*omep)-sin(6.*omep)*sin(12.*omep)+cos(9.*omep)*q)/Den;
		fac3=(sin(6.*omep)*q-(sin(6.*omep)-sin(12.*omep))*(sqrt(3.)*cos(4.*omep)/2.+sin(4.*omep)/2.))/Den;
	
		FitPoints = AnalPoints-8;
		Fitdata = realloc (Fitdata,(1+NCELLS)*FitPoints*sizeof(double)); //reallocate the array space for Fitdata, now that we have the number of data points to be fit
		
		for(int i=0; i<NCELLS; i++) //reallocate space for the arrays in *S[], each element in S[] will hold one data array (i.e., one sample string for one cell)
			{
			S[i] = realloc (S[i], FitPoints* sizeof(double));
			}
		
		for (i=0;i<(1+NCELLS);i++) //we need 4 blocks (NCELLS) for data points and 1 block for time
			{
			for(j=0;j<FitPoints;j++) 
				{
				if (i==0) //put time values into Fitdata on the first run through 
					{
					Fitdata[j]=Analdata[j+4]-Analdata[AnalPoints/2];
					}
				else  
					{
					Fitdata[i*FitPoints+j]=Analdata[i*AnalPoints+j+6]-Analdata[i*AnalPoints+j+2]+Analdata[i*AnalPoints+j+8]-
					Analdata[i*AnalPoints+j]-(Analdata[i*AnalPoints+j+7]-Analdata[i*AnalPoints+j+1])*fac3-
					(Analdata[i*AnalPoints+j+6]-Analdata[i*AnalPoints+j+2])*fac2;
					
					//put the data from Fitdata into the array S[][], organized by cell#
					}
				//if (i<NCELLS) 
				//	{
				//	S[i][j] = Fitdata[(i+1)*FitPoints+j];
				//	}
				}
			}
		for (i=0;i<NCELLS;i++) //load Fitdata into S[][]
			{
			for(j=0;j<FitPoints;j++) 
				{
				S[i][j] = Fitdata[(i+1)*FitPoints+j];
				}
			}
		}
	
	
	else if (om<60 && om>30) // filter for series6
		{
		ep=2.*Pi/(24.*om)-0.005;    
		omep=om*ep;
		q=sqrt(3.)*(cos(8.*omep)-cos(16.*omep))/2. + (sin(8.*omep)+sin(16.*omep))/2.;
		Den=sin(12.*omep)*sin(12.*omep) + 0.5*cos(18.*omep)*(sqrt(3.)*cos(8.*omep) + sin(8.*omep));
		fac2=(sin(12.*omep)*sin(12.*omep)-sin(12.*omep)*sin(24.*omep) + cos(18.*omep)*q)/Den;
		fac3=(sin(12.*omep)*q - (sin(12.*omep)-sin(24.*omep))*(sqrt(3.)*cos(8.*omep)/2. + sin(8.*omep)/2.))/Den;
		
		FitPoints=stopi-starti-16;
		
		Fitdata = realloc (Fitdata, (1+NCELLS)*FitPoints*sizeof(double));  
		memset(Fitdata, 0, (1+NCELLS)*FitPoints*sizeof(double));
		
		//FitdataHF = realloc (FitdataHF,(1+NCELLS)*FitPoints*sizeof(double));  
		//memset(FitdataHF, 0, (1+NCELLS)*FitPoints*sizeof(double));
		
		for(int i=0; i<NCELLS; i++) //reallocate space for the arrays in *S[], each element in S[] will hold one data array (i.e., one sample string for one cell)
			{
			S[i] = realloc (S[i], FitPoints* sizeof(double));
			}
		
		for (i=0;i<(1+NCELLS);i++) 
			{
			for(j=0;j<FitPoints;j++) 
				{
				//if (i==0) Fitdata[j]=Analdata[j+8]-Analdata[AnalPoints/2];  //define time values for first (AnalPoints) elements of Fitdata[]
				
				if (i==0) Fitdata[j]=Analdata[j+8];
				
				
				else Fitdata[i*FitPoints+j] = 1.0/(4.0*sqrt(3.0))*(Analdata[i*AnalPoints+j+16] - Analdata[i*AnalPoints+j+0] 
												+  Analdata[i*AnalPoints+j+12]  - Analdata[i*AnalPoints+j+4]
												- (Analdata[i*AnalPoints+j+14] - Analdata[i*AnalPoints+j+2])*fac3
												- (Analdata[i*AnalPoints+j+12] - Analdata[i*AnalPoints+j+4])*fac2);
				
				
				//else Fitdata[i*FitPoints+j] = Analdata[i*AnalPoints+j];
				}
			}
		for (i=0;i<NCELLS;i++) //load Fitdata into S[][]
			{
			for(j=0;j<FitPoints;j++) 
				{
				S[i][j] = Fitdata[(i+1)*FitPoints+j];
				}
			}
		}
	
	else if (om<30) // filter for 4 Hz signal
		{
		ep=2.*Pi/(48.*om)-0.005;    
		omep=om*ep;
		q=sqrt(3.)*(cos(8.*omep)-cos(16.*omep))/2. + (sin(8.*omep)+sin(16.*omep))/2.;
		Den=sin(12.*omep)*sin(12.*omep) + 0.5*cos(18.*omep)*(sqrt(3.)*cos(8.*omep) + sin(8.*omep));
		fac2=(sin(12.*omep)*sin(12.*omep)-sin(12.*omep)*sin(24.*omep) + cos(18.*omep)*q)/Den;
		fac3=(sin(12.*omep)*q - (sin(12.*omep)-sin(24.*omep))*(sqrt(3.)*cos(8.*omep)/2. + sin(8.*omep)/2.))/Den;
		
		FitPoints=stopi-starti-32;
		
		Fitdata = realloc (Fitdata, (1+NCELLS)*FitPoints*sizeof(double));  
		memset(Fitdata, 0, (1+NCELLS)*FitPoints*sizeof(double));
		
		//FitdataHF = realloc (FitdataHF,(1+NCELLS)*FitPoints*sizeof(double));  
		//memset(FitdataHF, 0, (1+NCELLS)*FitPoints*sizeof(double));
		
		for(int i=0; i<NCELLS; i++) //reallocate space for the arrays in *S[], each element in S[] will hold one data array (i.e., one sample string for one cell)
			{
			S[i] = realloc (S[i], FitPoints* sizeof(double));
			}
		
		for (i=0;i<(1+NCELLS);i++) 
			{
			for(j=0;j<FitPoints;j++) 
				{
				if (i==0) Fitdata[j]=Analdata[j+8]-Analdata[AnalPoints/2];  //define time values for first (AnalPoints) elements of Fitdata[]
				
				
				else  Fitdata[i*FitPoints+j] = 1.0/(4.0*sqrt(3.0))*(Analdata[i*AnalPoints+j+32] - Analdata[i*AnalPoints+j+0] 
												+  Analdata[i*AnalPoints+j+24]  - Analdata[i*AnalPoints+j+8]
												- (Analdata[i*AnalPoints+j+28] - Analdata[i*AnalPoints+j+4])*fac3
												- (Analdata[i*AnalPoints+j+24] - Analdata[i*AnalPoints+j+8])*fac2);
				
				
				//else  Fitdata[i*FitPoints+j] = Analdata[i*AnalPoints+j];
				}
			}
		for (i=0;i<NCELLS;i++) //load Fitdata into S[][]
			{
			for(j=0;j<FitPoints;j++) 
				{
				S[i][j] = Fitdata[(i+1)*FitPoints+j];
				}
			}
		}
	
	
	else
		{
		ep=2.*Pi/(16.*om)-0.005;    
		omep=om*ep;
		q=sqrt(2.)*(cos(18.*omep)-sin(18.*omep))/2.-sin(Pi/8.)*cos(9.*omep)+cos(Pi/8.)*sin(9.*omep);
		Den=sqrt(2.)*(cos(6.*omep)+sin(6.*omep))/2.*(-cos(12.*omep))-sin(8.*omep)*(-sin(Pi/8.)*cos(9.*omep)+cos(Pi/8.)*sin(9.*omep));
		fac2=((-cos(12.*omep)+sqrt(2.)*(cos(6.*omep)+sin(6.*omep))/2.)*(-cos(12.*omep))-sin(8.*omep)*q)/Den;
		fac3=(sqrt(2.)*(cos(6.*omep)+sin(6.*omep))/2.*q-(-sin(Pi/8.)*cos(9.*omep)+cos(Pi/8.)*sin(9.*omep))*(-cos(12.*omep)+sqrt(2.)*(cos(6.*omep)+sin(6.*omep))/2.))/Den;
		
		FitPoints=stopi-starti-12;
		Fitdata = realloc (Fitdata,(1+NCELLS)*FitPoints*sizeof(double)); //reallocate the array space for Fitdata, now that we have the number of data points to be fit
		
		for(int i=0; i<NCELLS; i++) //reallocate space for the arrays in *S[]; each element in S[] will hold one data array (i.e., one sample string for one cell)
			{
			S[i] = realloc (S[i], FitPoints* sizeof(double));
			}

		for (i=0;i<(1+NCELLS);i++) //we need 4 blocks (NCELLS) for data points and 1 block for time  
			{
			for(j=0;j<FitPoints;j++) 
				{
				if (i==0) //put time values into Fitdata on the first run through
					{
					Fitdata[j]=Analdata[j+6]-(Analdata[starti]+Analdata[stopi])/2.0;
					}
				else  
					{
					Fitdata[i*FitPoints+j]=Analdata[i*AnalPoints+j+12]-Analdata[i*AnalPoints+j]+Analdata[i*AnalPoints+j+9]-
					Analdata[i*AnalPoints+j+3]-(Analdata[i*AnalPoints+j+10]-Analdata[i*AnalPoints+j+2])*fac3 - 
					(Analdata[i*AnalPoints+j+9]-Analdata[i*AnalPoints+j+3])*fac2;
					}
				}
			}
		for (i=0;i<NCELLS;i++) //load Fitdata into S[][]
			{
			for(j=0;j<FitPoints;j++) 
				{
				S[i][j] = Fitdata[(i+1)*FitPoints+j];
				}
			}
		}



		
	
	
//////////////////////////// Experimental Chebyshev highpass filtering algorithm ////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/*
		a0 = 0.01868823;
		a1 = 0.03737647;
		a2 = 0.01868823;
		b1 = 1.593937;
		b2 = -0.6686903;
	
	
		a0 = 0.0386943;
		a2 = 0.0386943;
		a1 = 0.0773886;
		b1 = 1.392667;
		b2 = -0.5474446;
	
		FitPoints = stopi-starti;
		
		Fitdata = realloc (Fitdata, (1+NCELLS)*FitPoints*sizeof(double));  
		memset(Fitdata, 0, (1+NCELLS)*FitPoints*sizeof(double));
		
		Filterdata = realloc (Filterdata,(1+NCELLS)*FitPoints*sizeof(double));  
		memset(Filterdata, 0, (1+NCELLS)*FitPoints*sizeof(double));
		
		for (i=0;i<(1+NCELLS);i++) //we need 4 blocks (NCELLS) for data points and 1 block for time  
			{
			if (i==0) //put time values into Fitdata on the first run through
				{
				for(j=0;j<FitPoints;j++) Fitdata[j] = Analdata[j+6]-(Analdata[starti]+Analdata[stopi])/2.0;
				}
			else //the recursive filtering algorithm, defined for FitData[2] to Fitdata[FitPoints], calc. from AnalData[0] to AnalData[FitPoints] 
				{
				Filterdata[i*FitPoints]  = Analdata[i*FitPoints];
				Filterdata[i*FitPoints+1] = Analdata[i*FitPoints+1];
				
				for(j=2;j<FitPoints;j++)
				Filterdata[i*FitPoints+j] = a0*Analdata[i*FitPoints+j]
					+ a1 *   Analdata[i*FitPoints+j-1] + a2 *   Analdata[i*FitPoints+j-2]
					+ b1 * Filterdata[i*FitPoints+j-1] + b2 * Filterdata[i*FitPoints+j-2];
				
				Fitdata[(i+1)*FitPoints-1] = Filterdata[(i+1)*FitPoints-1];
				Fitdata[(i+1)*FitPoints-2] = Filterdata[(i+1)*FitPoints-2];
				
				for(j=3;j<=FitPoints;j++)
				Fitdata[(i+1)*FitPoints-j] = a0*Filterdata[(i+1)*FitPoints-j]
					+ a1 * Filterdata[(i+1)*FitPoints-j+1] + a2 * Filterdata[(i+1)*FitPoints-j+2]
					+ b1 *  Fitdata[(i+1)*FitPoints-j+1] + b2 *  Fitdata[(i+1)*FitPoints-j+2];
				}
			}
		
		FitPoints -= 20; //re-define FitPoints to allocate proper amount of space for S[] arrays, & for use in calculating T[]
		
		for(int i=0; i<NCELLS; i++) //reallocate space for the arrays in *S[]; each element in S[] will hold one data array (i.e., one sample string for one cell)
			{
			S[i] = realloc (S[i], FitPoints* sizeof(double)); //allocate space for S[]--must have FitPoints for T[] array calculation
			}
	
		for (i=0;i<NCELLS;i++) //load Fitdata into S[][]
			{
			for(j=0;j<FitPoints;j++) 
				{
				S[i][j] = Fitdata[(i+1)*(FitPoints+20)+j+10];
				}
			}
	*/
	
	GetCtrlVal(aph,AP_TArrayAvgPts,&TAvgPts);
	
	if (sample == 1) 
		{
		TshortPtsA = floor((FitPoints-24)/TAvgPts); //T array length after averaging points
		if (om<30)  TshortPtsA = floor((FitPoints-48)/TAvgPts); 
		
		TmiddleA = realloc (TmiddleA, TshortPtsA*sizeof(double)); //MT-MB cell phase difference array for output to UI
		TouterA = realloc (TouterA, TshortPtsA*sizeof(double)); //OT-OB cell array					"	
		
		Tdiff = realloc (Tdiff, 7*TshortPtsA*sizeof(double)); //difference array for all cell pairs to extract phase difference w/o fitting for freq. difference
		
		if (sernum == serstart) //diagnostic arrays to examine coherent structure on T[] signals
			{
			TmiddleA_Sum = realloc(TmiddleA_Sum, TshortPtsA*sizeof(double));
			TmiddleA_Avg = realloc(TmiddleA_Avg, TshortPtsA*sizeof(double));
			TouterA_Sum = realloc(TouterA_Sum, TshortPtsA*sizeof(double));
			TouterA_Avg = realloc(TouterA_Avg, TshortPtsA*sizeof(double));
			}
		}
	
	if (sample == 2) 
		{
		TshortPtsB = floor((FitPoints-24)/TAvgPts); 
		if (om<30)  TshortPtsB = floor((FitPoints-48)/TAvgPts);
		
		TmiddleB = realloc (TmiddleB, TshortPtsB*sizeof(double)); //MT-MB cell phase difference array for output to UI
		TouterB = realloc (TouterB, TshortPtsB*sizeof(double)); //OT-OB cell array
		
		if (sernum == serstart) //diagnostic arrays to examine coherent structure on T[] signals
			{
			TmiddleB_Sum = realloc(TmiddleB_Sum, TshortPtsB*sizeof(double));
			TmiddleB_Avg = realloc(TmiddleB_Avg, TshortPtsB*sizeof(double));
			TouterB_Sum = realloc(TouterB_Sum, TshortPtsB*sizeof(double));
			TouterB_Avg = realloc(TouterB_Avg, TshortPtsB*sizeof(double));
			}
		}
	
	free(Filterdata);

	free(Wa);
	free(Wb);

	return 0;
}

static int FitData(void) //calls fitting routine on data arrays, calculates residuals and handles amplitude and phase deviation fitting
	{
	int vary[ncoef]; //the vector of binary values to determine which parameters should be fit to in the chi squared routine
	int i,j,k,seg,guesserr=0;
	double tcoef[NCELLS*ncoef], terrors[NCELLS*ncoef],ave,dw,dp,err;
	//double pplus[NCELLS*nseg],pmin[NCELLS*nseg],aplus[NCELLS*nseg],amin[NCELLS*nseg],temp[nseg],dpseg[nseg];
	double frequency_array[FitPoints];//For storing power spectra of residuals, BG 02/11/13

    Resid=realloc(Resid,NCELLS*FitPoints*sizeof(double));  
    guesserr=Guess();
	
	for (i=0; i<4; i++) vary[i] = 1;
	vary[4] = 0; //don't fit the midtime in the routine (BG 08/27/10)
    
	for (k=0;k<NCELLS;k++) //call the non-linear fitting routine for each cell
		{
		fit=k; //the value of fit will be checked inside NLF to determine which cell signal is being fit to

   		SetCtrlVal(aph,AP_Ind,k+3); //Set the status bar indicator
		
		//Pass the x-value, y-value start points, the # of points to fit, the coefficient array start point,
		//the vary array start point, the number of coefficients, and the error array start point to nonlinear fit routine
		NLF(&Fitdata[0], &Fitdata[FitPoints*(k+1)], FitPoints, &coef[ncoef*k], &vary[0], ncoef, &errors[ncoef*k], sample);
		ProcessSystemEvents();
        
		for (i=0;i<FitPoints;i++) //calculate the residuals once the fitted data are returned
			{
       		Resid[FitPoints*k+i] = Fitdata[FitPoints*(k+1)+i]-fun(Fitdata[i], &coef[ncoef*k]);
       		}
    	}
	
	DeleteGraphPlot (aph, AP_Resid, -1,VAL_DELAYED_DRAW);
	SetCtrlAttribute (aph, AP_Resid, ATTR_REFRESH_GRAPH, 0);
	
	DeleteGraphPlot (aph, AP_Resid2, -1,VAL_DELAYED_DRAW);
	SetCtrlAttribute (aph, AP_Resid2, ATTR_REFRESH_GRAPH, 0);
	
    for (i=0;i<FitPoints/2;i++) frequency_array[i] = i*200/FitPoints;

	for (k=0; k<NCELLS; k++)
		{
		Spectrum (&Fitdata[FitPoints*(k+1)], FitPoints);

		if (graphsel[k]==1)
			{
       		PlotXY (aph,AP_Resid,&frequency_array[0],&Fitdata[FitPoints*(k+1)],FitPoints/2, VAL_DOUBLE,VAL_DOUBLE,VAL_THIN_LINE,VAL_EMPTY_SQUARE,VAL_SOLID,1,ColorArray[k]);
       		}
       	else 
			{
	       	PlotXY (aph,AP_Resid2,&frequency_array[0],&Fitdata[FitPoints*(k+1)],FitPoints/2,VAL_DOUBLE,VAL_DOUBLE,VAL_THIN_LINE,VAL_EMPTY_SQUARE,VAL_SOLID,1,ColorArray[k]);
       		}

		}
	
	SetCtrlAttribute (aph, AP_Resid, ATTR_REFRESH_GRAPH, 1);
    SetCtrlAttribute (aph, AP_Resid, ATTR_ENABLE_ZOOM_AND_PAN, 1); 
    SetCtrlAttribute (aph, AP_Resid2, ATTR_REFRESH_GRAPH, 1);
    SetCtrlAttribute (aph, AP_Resid2, ATTR_ENABLE_ZOOM_AND_PAN, 1); 

	SetCtrlVal(aph,AP_Ind,7);
	
	return 0;
	}

static int WriteSum()
	{
	// T-array output algorithm: averages 6 points of T[] arrays, time values to summary file *.sum
	// T[] values for each period must be stored in a master array with enough space for all cell pairs to work properly

	FILE *fs;

	int i,j,k,m,n;
	int month,day,year,hours,min,sec;   
	int error;
	int AvPts = 1;
	int foo = floor((FitPoints/AvPts)+1.0); 
	
	double T[6];
	double Holder[7][foo];
	double timeAvg;
	
	/*
	if(sample == 1) //open *.sum file for writing
		{	
		sprintf(sumfilename,"%sSeries7_%d.sum",outdircum,sernum); 
		fs = fopen (sumfilename, "w");
		GetFileDate(readfilename,&month,&day,&year);
		GetFileTime(readfilename,&hours,&min,&sec);
		fprintf(fs,"#File created on %d-%d-%d at %d:%d:%d\n",month,day,year,hours,min,sec); //output header
		fprintf(fs, "#%9s%21s%21s%21s%21s%21s%21s\n","Time","T_12","T_13","T_14","T_23","T_24","T_34"); //format headline string
		
		for(int i=2; i<floor((FitPoints-12)/6); i++) //output 'A' period data--loop over data points 
			{
			for(int j=0; j<6; j++) //loop over cell differences
				{   
				T[j] = 0.0;
				for(int k=0; k<6; k++) //loop over averaging points
					{
					T[j] += Ta[j][i*6-12+k]/6;
					}
				}
			timeAvg = 0.0;
			for(int k=0; k<6; k++) timeAvg += Fitdata[i*6+k]/6;
			fprintf(fs,"%21.12f%21.12f%21.12f%21.12f%21.12f%21.12f%21.12f\n",timeAvg,T[0],T[1],T[2],T[3],T[4],T[5]);
			}
		fclose(fs);
		}
	if (sample == 2) //once all B-period T[] arrays have been calculated 
		{
		fs = fopen (sumfilename, "a"); //open *.sum file for appending 
		
		for(int i=2; i<floor((FitPoints-12)/6); i++) //output 'B' period data--loop over data points
			{
			for(int j=0; j<6; j++)  //loop over cell differences
				{   
				T[j] = 0.0;
				for(int k=0; k<6; k++) //loop over averaging points
					{
					T[j] += Tb[j][i*6-12+k]/6;
					}
				}
			timeAvg = 0.0;
			for(int k=0; k<6; k++) timeAvg += Fitdata[i*6+k]/6;
			fprintf(fs,"%21.12f%21.12f%21.12f%21.12f%21.12f%21.12f%21.12f\n",timeAvg,T[0],T[1],T[2],T[3],T[4],T[5]);
			}
		fclose(fs);
		}
	return 0;
	}
	*/

	if(sample == 1) //open *.sum file for writing
		{	
		sprintf(sumfilename,"%sSeries7_%d.sum",outdircum,sernum); 
		fs = fopen (sumfilename, "w");
		GetFileDate(readfilename,&month,&day,&year);
		GetFileTime(readfilename,&hours,&min,&sec);
		fprintf(fs,"#File created on %d-%d-%d at %d:%d:%d\n",month,day,year,hours,min,sec); //output header
		fprintf(fs, "#%9s%21s%21s%21s%21s%21s%21s\n","Time","T_12","T_13","T_14","T_23","T_24","T_34"); //format headline string
		
		m=0; //initialize the Holder index values
		n=0;
		
		for(int i=FitPoints-25; i-AvPts>=0; i=i-AvPts) //output 'A' period data--loop over data points 
			// should be i-AvPts>=0 ?
			{
			m=0;
			Holder[m][n] = 0.0;
			for(int k=0; k<AvPts; k++) Holder[m][n] += Fitdata[i-k+12]/AvPts; //average AvPts of the time array
			// should be FitData[i-k+12] ?
			m++;
			
			for(int j=0; j<6; j++) //loop over cell differences
				{   
				//T[j] = 0.0;
				Holder[m][n] = 0.0;  //we'll need to invert the A-period values after computing them going backwards   
				for(int k=0; k<AvPts; k++) //loop over averaging points
					{
					Holder[m][n] += Ta[j][i-k]/AvPts;
					}
				m++; //increment cell index
				}
			n++; //incrment holder data array index
			//fprintf(fs,"%21.12f%21.12f%21.12f%21.12f%21.12f%21.12f%21.12f\n",timeAvg,T[0],T[1],T[2],T[3],T[4],T[5]);
			}	
		n--; //reverse the last increment of n to start with array values which are actually occupied
		while (n>=0) //now that the holder array is full, spit it back in reverse order so that the timing makes sense
			{
			fprintf(fs,"%21.12f%21.12f%21.12f%21.12f%21.12f%21.12f%21.12f\n",Holder[0][n],Holder[1][n],Holder[2][n],Holder[3][n],Holder[4][n],Holder[5][n],Holder[6][n]); 
			n--;
			}
		fclose(fs);
		}
	if (sample == 2) //once all B-period T[] arrays have been calculated 
		{
		fs = fopen (sumfilename, "a"); //open *.sum file for appending 
		
		for(int i=12; i+AvPts<FitPoints-12; i=i+AvPts) //output 'B' period data--loop over data points
			{
			for(int j=0; j<6; j++)  //loop over cell differences
				{   
				T[j] = 0.0;
				for(int k=0; k<AvPts; k++) //loop over averaging points
					{
					T[j] += Tb[j][i+k-12]/AvPts;
					// should be [i+k-12] ?
					}
				}
			timeAvg = 0.0;
			
			for(int k=0; k<AvPts; k++) timeAvg += Fitdata[i+k]/AvPts; //average AvPts of the time array
			
			fprintf(fs,"%21.12f%21.12f%21.12f%21.12f%21.12f%21.12f%21.12f\n",timeAvg,T[0],T[1],T[2],T[3],T[4],T[5]);
			}
		fclose(fs);
		}
	return 0;
	}

static int ProductFit(int cell1, int cell2)
//Normalizes the S[][] data arrays and computes antisymmetric product combination T for all cell pairs 
//Determines the phase, frequency difference between cell signal pairs for each sample
	{
	GetCtrlVal(aph,AP_TArrayAvgPts,&TAvgPts);
	int TPoints = floor((FitPoints-24)/TAvgPts); 
	int pair = 0; //index variable to ID cell pair
	
	static double *Ra; Ra = malloc((FitPoints)*sizeof(double));
	static double *Rb; Rb = malloc((FitPoints)*sizeof(double));
	static double *Wa; Wa = malloc((FitPoints)*sizeof(double));
	static double *Wb; Wb = malloc((FitPoints)*sizeof(double));
	//static double *T;  T  = malloc((FitPoints)*sizeof(double));
	
	double Deviation[FitPoints-24]; //holder array for difference between raw data, fit function
	double TShort[TPoints];
	double TimeBase[TPoints];
	double Sx = 0.0;
	double Sy = 0.0;
	double Sxx = 0.0;
	double Sxy = 0.0;
	double Delta = 0.0;
	double mean = 0;
	double sigma = 0;
	double cutoff=0;
	double WsumA = 0;
	double WsumB = 0;
	double *TShort_square=0;
	double mse;
	double err = 0.0;
	
	int TdiffPts = 0;
	
	double TFitOutput[TPoints];		   //output variables for reults of 2nd-order 
	double TFitCoeff[3], TFitError;	   //polynomial fit to residuals for (d/dt)Dw
	
	//variable 'pair' records which cell difference we're calculating:
	//MT-MB => pair = 0, MT-OT => pair = 1, etc.
	if (cell1 == 0) pair = cell1+cell2-1;
	if (cell1 != 0) pair = cell1+cell2;
	
	//allocate array space
	if(sample == 1) Ta[pair] = realloc(Ta[pair], (FitPoints-12) * sizeof(double));
	if(sample == 2) Tb[pair] = realloc(Tb[pair], (FitPoints-12) * sizeof(double));
	
	//calculate the exponential decay piece of the signal (used to normalize the data in Sn[][])
	for(int i=6; i<FitPoints-6; i++) 
		{
		Wa[i-6] = sqrt(S[cell1][i]*S[cell1][i] - S[cell1][i-6]*S[cell1][i+6]);
		Wb[i-6] = sqrt(S[cell2][i]*S[cell2][i] - S[cell2][i-6]*S[cell2][i+6]);
		}

	if (sample == 1) //get ending amplitude for A period
		{
		if(cell1 == 0 && cell2 == 1) //ending amplitude for middle cells
			{
			AmpA1=0.0;
			AmpA2=0.0;
			for(int i=FitPoints-12-192; i<FitPoints-12; i++)
				{
				AmpA1+=Wa[i]/192.;
				AmpA2+=Wb[i]/192.;
				}
			}
		if (cell1 == 2 && cell2 == 3) //ending amplitude for outer cells
			{
			AmpA3=0.0;
			AmpA4=0.0;
			for(int i=FitPoints-12-192; i<FitPoints-12; i++)
				{
				AmpA3+=Wa[i]/192.;
				AmpA4+=Wb[i]/192.;
				}
			}
		}
			
	if (sample == 2) //get B period starting amplitude
		{
		if(cell1 == 0 && cell2 == 1) //B period starting amplitude for inner cells 
			{
			AmpB1=0.0;
			AmpB2=0.0;
			for(int i=0; i<192; i++)
				{
				AmpB1+=Wa[i]/192.;
				AmpB2+=Wb[i]/192.;
				}
			}
		if (cell1 == 2 && cell2 == 3) //B period starting amplitude for outer cells  
			{
			AmpB3=0.0;
			AmpB4=0.0;
			for(int i=0; i<192; i++)
				{
				AmpB3+=Wa[i]/192.;
				AmpB4+=Wb[i]/192.;
				}
			}
		}

	for(int i=6; i<FitPoints-6; i++) 
		{
		Ra[i-6]=S[cell1][i]/Wa[i-6]; //Ra[0] corresponds to S[6], should be a sine wave with amplitude 1.0
		Rb[i-6]=S[cell2][i]/Wb[i-6];
		}	 	

	for(int i=12; i<FitPoints-12; i++) 
		{
		Wa[i-6]=0.5*(Ra[i]-Ra[i-12]); // Wa[0] corresponds to S[6]
		Wb[i-6]=0.5*(Rb[i]-Rb[i-12]);
		}

	if (sample == 1)
		{
		//calculate the product combination T[] for the two data arrays
		//for(int j=12; j<FitPoints-12; j++) Ta[pair][j-12] = asin(Ra[j-6]*Wb[j-6] - Rb[j-6]*Wa[j-6]);
		for(int j=12; j<FitPoints-12; j++) Ta[pair][j-12] = (Ra[j-6]*Wb[j-6] - Rb[j-6]*Wa[j-6]);
		
		//local variable TPoints should be equal to global TshortPtsA
		for(int j = TPoints-1; j > -1; j--) // make a smaller Time array and T array
			{
			TimeBase[j] = 0.0; //initialize TimeBase[j] 
			TShort[j] = 0.0;  //initialize TShort[j]
			for(int i=0; i<TAvgPts; i++) //sum up TAvgPts points of Time array
				{
				TimeBase[j] += Fitdata[FitPoints - 12 - (TPoints-j)*TAvgPts +i]/(TAvgPts*1.0);
				TShort[j] += Ta[pair][FitPoints - 24 - (TPoints-j)*TAvgPts +i]/(TAvgPts*1.0);
				}

			//TimeDiff will end up as -1.0 times the last element in TimeBase (the earliest point in the averaged dataset)			
			if (cell1 == 0 && cell2 == 1) 
				{
				TimeZero = TimeBase[TPoints-1];
				MidtimeA = TimeZero;
				TimeDiff = -1.0 * TimeBase[j]; 
				}
			
			//assign negative value of Tshort to T difference array
			Tdiff[TshortPtsA * pair + j] = -1.0 * TShort[j]; 
			}
		}
	
	if(sample == 2)
		{
		//calculate the product combination T[] for the two data arrays
		//for(int j=12; j<FitPoints-12; j++) Tb[pair][j-12] = asin(Ra[j-6]*Wb[j-6] - Rb[j-6]*Wa[j-6]);
		for(int j=12; j<FitPoints-12; j++) Tb[pair][j-12] = Ra[j-6]*Wb[j-6] - Rb[j-6]*Wa[j-6];

		
		//local variable TPoints should be equal to global TshortPtsB
		for(int j=0; j<TPoints; j++) // make a smaller Time array and T array
			{
			TimeBase[j]=0.0;
			TShort[j]=0.0;
			for(int i=0; i<TAvgPts; i++) //average TAvgPts points of T array
				{
				TimeBase[j] += Fitdata[TAvgPts*j + i+12]/(TAvgPts*1.0);
				TShort[j] += Tb[pair][TAvgPts*j + i]/(TAvgPts*1.0);
				}
			}
		
		//add B period start time to TimeDiff
		if (cell1 == 0 && cell2 == 1) 
			{
			TimeZero = TimeBase[0];
			MidtimeB = TimeZero;
			TimeDiff += TimeBase[0];  
			}

		TdiffPts = TshortPtsA;
		if(TshortPtsB < TshortPtsA) TdiffPts = TshortPtsB;
		
		TdiffDw[pair] = 0.0; //initialize average, deviation sums
		TdiffDwErr[pair] = 0.0;

		for(int j=0; j<TdiffPts; j++)
			{
			Tdiff[TshortPtsA*pair+j] += TShort[j]; //add B-period value of Tshort to T difference (phase difference) array 
			Tdiff[TshortPtsA*pair+j] = Tdiff[TshortPtsA*pair+j]/TimeDiff; //divide T difference by dark time to get freq. diff. 
			TdiffDw[pair] += Tdiff[TshortPtsA*pair+j]/TdiffPts; //add value of frequency difference to average value array
			}																		
		for(int j=0; j<TdiffPts; j++)
			{
			//take the sum of the squared deviations from the avg. divided by # of data pts. as the std. error of the mean
			TdiffDwErr[pair] += ((TdiffDw[pair]-Tdiff[TshortPtsA*pair+j])*(TdiffDw[pair]-Tdiff[TshortPtsA*pair+j]))/(TdiffPts*TdiffPts);
			}
		TdiffDwErr[pair] = sqrt(TdiffDwErr[pair])*(56.0/48.0);
		}
	
	//re-initialize the fit parameters to fit the shorter T[] array
	Sx = 0.0;
	Sxx = 0.0;
	Sy = 0.0;
	Sxy = 0.0;
	
	//compute the linear fit parameters, following the notation of Numerical Recipes section 15.2 
	for (int k=0; k<TPoints; k++)
		{
		Sx += (TimeBase[k]-TimeZero);
		Sxx +=  (TimeBase[k]-TimeZero)*(TimeBase[k]-TimeZero);
		Sy += TShort[k];
		Sxy += TShort[k]*(TimeBase[k]-TimeZero);
		}

	Delta = TPoints*Sxx-Sx*Sx;
	
	*Dphi[sample-1][cell1][cell2] = (Sxx*Sy-Sx*Sxy)/(Delta); 
	*Dw[sample-1][cell1][cell2] = (TPoints*Sxy-Sx*Sy)/(Delta);   
	
	chi2 = 0.0; //initialize chi^2 to 0
	for (int l=0; l<TPoints; l++) //compute chi squared in order to get uncertainty estimates w/o error bars on individual points
		{
		chi2 += ((TShort[l])-*Dphi[sample-1][cell1][cell2]-*Dw[sample-1][cell1][cell2]*(TimeBase[l]-TimeZero))*((TShort[l])-*Dphi[sample-1][cell1][cell2]-*Dw[sample-1][cell1][cell2]*(TimeBase[l]-TimeZero));
		}

	//"correct" error estimates in NR by multplying by sqrt(chi^2)
	*Sphi[sample-1][cell1][cell2] = sqrt(fabs(Sxx/Delta))*sqrt(chi2/(TPoints-2))*(56.0/48.0); //fudge factor to account for correlated points in T[] arrays (BG 04/29/2014)  
	*Sw[sample-1][cell1][cell2] = sqrt(fabs(TPoints/Delta))*sqrt(chi2/(TPoints-2)); 	  
	
	//plot the averaged T arrays for cell pairs (1,2) and (3,4)
    if (sample == 1) 
		{
		if (cell1 == 0 && cell2 == 1) 
			{
			for(int j=0; j<TPoints; j++) 
				{
				TmiddleA[j] = TShort[j] - (*Dphi[0][0][1] + *Dw[0][0][1]*(TimeBase[j]-TimeZero));
				}
			PlotXY (aph, AP_AmpDev, &Fitdata[0], &TmiddleA[0], TPoints,  VAL_DOUBLE, VAL_DOUBLE, VAL_THIN_LINE, VAL_EMPTY_SQUARE, VAL_SOLID, 1, VAL_GREEN);
			PolyFit (&Fitdata[0], &TmiddleA[0], TPoints, 2, &TFitOutput[0], &TFitCoeff[0], &TFitError);
			DOmegaDot12A = TFitCoeff[2]; 
			}
		if (cell1 == 2 && cell2 == 3) 
			{
			for(int j=0; j<TPoints; j++) 
				{
				TouterA[j] =  TShort[j] - (*Dphi[0][2][3] + *Dw[0][2][3]*(TimeBase[j]-TimeZero));
				}
			PlotXY (aph, AP_AmpDev, &Fitdata[0], &TouterA[0], TPoints, VAL_DOUBLE, VAL_DOUBLE, VAL_THIN_LINE, VAL_EMPTY_SQUARE, VAL_SOLID, 1, VAL_YELLOW);
			PolyFit (&Fitdata[0], &TouterA[0], TPoints, 2, &TFitOutput[0], &TFitCoeff[0], &TFitError);
			DOmegaDot34A = TFitCoeff[2];
			//WriteSum();
			}
		}
    if (sample == 2) 
		{	  
		if (cell1 == 0 && cell2 == 1) 
			{
			for(int j=0; j<TPoints; j++) 
				{
				TmiddleB[j] = TShort[j] - (*Dphi[1][0][1] + *Dw[1][0][1]*(TimeBase[j]-TimeZero));
				}
			PlotXY (aph, AP_AmpDev2, &Fitdata[0], &TmiddleB[0], TPoints,  VAL_DOUBLE, VAL_DOUBLE, VAL_THIN_LINE, VAL_EMPTY_SQUARE, VAL_SOLID, 1, VAL_CYAN);
			PolyFit (&Fitdata[0], &TmiddleB[0], TPoints, 2, &TFitOutput[0], &TFitCoeff[0], &TFitError);
			}

		if (cell1 == 2 && cell2 == 3) 
			{
			for(int j=0; j<TPoints; j++) 
				{
				TouterB[j] =  TShort[j] - (*Dphi[1][2][3] + *Dw[1][2][3]*(TimeBase[j]-TimeZero));
				}
			PlotXY (aph, AP_AmpDev2, &Fitdata[0], &TouterB[0], TPoints, VAL_DOUBLE, VAL_DOUBLE, VAL_THIN_LINE, VAL_EMPTY_SQUARE, VAL_SOLID, 1, VAL_WHITE);
			PolyFit (&Fitdata[0], &TouterB[0], TPoints, 2, &TFitOutput[0], &TFitCoeff[0], &TFitError);
			//WriteSum();
			}
		}
	
	free(Ra);
	free(Rb);
	free(Wa);
	free(Wb);

	return 0;
	}
	
//**********************************************************************************************	
	//Thiel-Sen estimator algorithm: calculates slope of the array T[] 
	//by averaging slopes of all lines passing through pairs of points
/*
	if(sample==1)
		{
		//allocate array space
		Ta[pair] = realloc(Ta[pair], 2 * TPoints * sizeof(double));
		
		//average arrays
		for(int j=0; j<TPoints; j++)
			{
			Ta[pair][j] = 0.0;
			Ta[pair][TPoints+j] = 0.0;
			for(int i=0; i<TAvgPts; i++) //sum up TAvgPts points
				{
				Ta[pair][j] += Fitdata[TAvgPts*j +i +12]; //time data in 1st block
				Ta[pair][TPoints+j] += T[TAvgPts*j +i +12]; //T[] values in 2nd block
				}
			Ta[pair][j] = Ta[pair][j]/TAvgPts;
			Ta[pair][TPoints+j] = Ta[pair][TPoints+j]/TAvgPts;			
			}
		}
		
	if(sample==2)
		{
		//allocate array space
		Tb[pair] = realloc(Tb[pair], 2 * TPoints * sizeof(double));
		
		//average arrays
		for(int j=0; j<TPoints; j++)
			{
			Tb[pair][j] = 0.0;
			Tb[pair][TPoints+j] = 0.0;
			for(int i=0; i<TAvgPts; i++) //sum up TAvgPts points
				{
				Tb[pair][j] += Fitdata[TAvgPts*j +i +12]; //time data in 1st block
				Tb[pair][TPoints+j] += T[TAvgPts*j +i +12]; //T[] values in 2nd block
				}
			Tb[pair][j] = Tb[pair][j]/TAvgPts;
			Tb[pair][TPoints+j] = Tb[pair][TPoints+j]/TAvgPts;			
			}
		
		TS_Slope = realloc(TS_Slope, TshortPtsA*TshortPtsB*sizeof(double));
		
		for (int m=0; m < TshortPtsA; m++)
			{
			for(int n=0; n<TshortPtsB; n++) TS_Slope[m*TshortPtsB + n] = (Tb[pair][TshortPtsB+n]-Ta[pair][TshortPtsA+m])/((Tb[pair][n]-Ta[pair][m])); 
			}
		Median (TS_Slope, TshortPtsA*TshortPtsB, &TS_Dw[pair]); //store median slope as freq. difference
		}
	
*/
//****************************************** takes average pairwise slope instead of median ******************************************
	
	
/*	if(sample==1)   
		{
		//record A-period FitPoints value FitPointsA & allocate array space
		FitPointsA = FitPoints-24; 
		Ta[pair] = realloc(Ta[pair], 2* FitPointsA * sizeof(double));
		
		for(int k=0; k<FitPointsA; k++) //record time and T[] values for each cell pair in Ta[pair][time+Dphi]
			{
			Ta[pair][k] = Fitdata[k + 12];
			Ta[pair][FitPointsA+k] = T[k]; 
			}
		}
	
	if(sample==2)
		{
		//record B-period FitPoints value FitPointsB & allocate array space
		FitPointsB = FitPoints-24; 
		Tb[pair] = realloc(Tb[pair], 2* FitPointsB * sizeof(double));
		
		for(int k=0; k<FitPointsB; k++) //record time and T[] values for each cell pair in Tb[pair][time+Dphi]
			{
			Tb[pair][k] = Fitdata[k + 12];
			Tb[pair][FitPointsB+k] = T[k]; 
			}
		
		TS_Dw[pair] = 0.0; //initalize slope average
		for (int a=0; a<FitPointsA; a++)
			{
			for (int b=0; b<FitPointsB; b++)
				{
				//TS estimator = SUM(Delta_T/(N*Delta_t))
				TS_Dw[pair] += (Tb[pair][FitPointsB+b]-Ta[pair][FitPointsA+a])/((Tb[pair][b]-Ta[pair][a])*(FitPointsB*FitPointsA));
				}
			}
		}
*/
//**********************************************************************************************
				
//////////////////////////Original ProductComboFit function for multiple cell differences//////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////


static int ProductComboFit(int cell1, int cell2, double C12, int cell3, int cell4, double C34, int cell5, int cell6, double C56, int listPlace)
//Takes data from multiple cell pairs and computes linear phase/freqency differences for 4 or 6-cell 
//combinations by adding individual T functions multiplied by coefficients C12, C34, C56
	{
	int err = 0;
	GetCtrlVal(aph,AP_TArrayAvgPts,&TAvgPts); 
	int TPoints = floor((FitPoints-24)/TAvgPts); 
	
//assign these data arrays to be 'static'-->allocates RAM from the heap instead of the stack (limited to 1MB) 
	static double *R1; R1 = malloc((FitPoints-12)*sizeof(double));
	static double *R2; R2 = malloc((FitPoints-12)*sizeof(double));
	static double *R3; R3 = malloc((FitPoints-12)*sizeof(double));
	static double *R4; R4 = malloc((FitPoints-12)*sizeof(double));
	static double *R5; R5 = malloc((FitPoints-12)*sizeof(double));
	static double *R6; R6 = malloc((FitPoints-12)*sizeof(double));
	static double *W1; W1 = malloc((FitPoints-12)*sizeof(double));
	static double *W2; W2 = malloc((FitPoints-12)*sizeof(double));
	static double *W3; W3 = malloc((FitPoints-12)*sizeof(double));
	static double *W4; W4 = malloc((FitPoints-12)*sizeof(double));
	static double *W5; W5 = malloc((FitPoints-12)*sizeof(double));
	static double *W6; W6 = malloc((FitPoints-12)*sizeof(double));
	
	static double *T12; T12 = malloc((FitPoints-24)*sizeof(double));
	static double *T34; T34 = malloc((FitPoints-24)*sizeof(double));
	static double *T56; T56 = malloc((FitPoints-24)*sizeof(double));
	
	double T12Short[TPoints];
	double T34Short[TPoints];
	double T56Short[TPoints];
	double TShort[TPoints];
	
	double TimeBase[TPoints];
	double TimeZero=0.0;
	double Sx = 0.0;
	double Sy = 0.0;
	double Sxx = 0.0;
	double Sxy = 0.0;
	double Delta = 0.0;
	double q[2], r[2];
	double mean = 0;

	//Normalize the data in Sn[][] by dividing out exponential decay function
	if (cell1 != 0) for(int i=6; i<FitPoints-6; i++) W1[i-6] = sqrt(S[cell1-1][i]*S[cell1-1][i] - S[cell1-1][i-6]*S[cell1-1][i+6]);
	if (cell2 != 0) for(int i=6; i<FitPoints-6; i++) W2[i-6] = sqrt(S[cell2-1][i]*S[cell2-1][i] - S[cell2-1][i-6]*S[cell2-1][i+6]);
	if (cell3 != 0) for(int i=6; i<FitPoints-6; i++) W3[i-6] = sqrt(S[cell3-1][i]*S[cell3-1][i] - S[cell3-1][i-6]*S[cell3-1][i+6]);
	if (cell4 != 0) for(int i=6; i<FitPoints-6; i++) W4[i-6] = sqrt(S[cell4-1][i]*S[cell4-1][i] - S[cell4-1][i-6]*S[cell4-1][i+6]);
	if (cell5 != 0) for(int i=6; i<FitPoints-6; i++) W5[i-6] = sqrt(S[cell5-1][i]*S[cell5-1][i] - S[cell5-1][i-6]*S[cell5-1][i+6]);
	if (cell6 != 0) for(int i=6; i<FitPoints-6; i++) W6[i-6] = sqrt(S[cell6-1][i]*S[cell6-1][i] - S[cell6-1][i-6]*S[cell6-1][i+6]);
	
	if (cell1 != 0) for(int i=6; i<FitPoints-6; i++) R1[i-6]=S[cell1-1][i]/W1[i-6]; //Rn[0] corresponds to S[cell(n)][6]
	if (cell2 != 0) for(int i=6; i<FitPoints-6; i++) R2[i-6]=S[cell2-1][i]/W2[i-6];
	if (cell3 != 0) for(int i=6; i<FitPoints-6; i++) R3[i-6]=S[cell3-1][i]/W3[i-6];
	if (cell4 != 0) for(int i=6; i<FitPoints-6; i++) R4[i-6]=S[cell4-1][i]/W4[i-6];
	if (cell5 != 0) for(int i=6; i<FitPoints-6; i++) R5[i-6]=S[cell5-1][i]/W5[i-6];
	if (cell6 != 0) for(int i=6; i<FitPoints-6; i++) R6[i-6]=S[cell6-1][i]/W6[i-6];
	
	if (cell1 != 0) for(int i=12; i<FitPoints-12; i++) W1[i-6]=0.5*(R1[i]-R1[i-12]); //Wn[0] corresponds to S[cell(n)][6]
	if (cell2 != 0) for(int i=12; i<FitPoints-12; i++) W2[i-6]=0.5*(R2[i]-R2[i-12]);
	if (cell3 != 0) for(int i=12; i<FitPoints-12; i++) W3[i-6]=0.5*(R3[i]-R3[i-12]);
	if (cell4 != 0) for(int i=12; i<FitPoints-12; i++) W4[i-6]=0.5*(R4[i]-R4[i-12]);
	if (cell5 != 0) for(int i=12; i<FitPoints-12; i++) W5[i-6]=0.5*(R5[i]-R5[i-12]);
	if (cell6 != 0) for(int i=12; i<FitPoints-12; i++) W6[i-6]=0.5*(R6[i]-R6[i-12]);

	 //calculate the product combination T[] for the pairs of data arrays
	//if (cell1 != 0 && cell2 != 0) for(int j=12; j<FitPoints-12; j++) T12[j-12] = asin(R1[j-6]*W2[j-6] - R2[j-6]*W1[j-6]);
	if (cell1 != 0 && cell2 != 0) for(int j=12; j<FitPoints-12; j++) T12[j-12] = R1[j-6]*W2[j-6] - R2[j-6]*W1[j-6];
	else for(int j=12; j<FitPoints-12; j++) T12[j-12] = 0.0;
	
	//if (cell3 != 0 && cell4 != 0) for(int j=12; j<FitPoints-12; j++) T34[j-12] = asin(R3[j-6]*W4[j-6] - R4[j-6]*W3[j-6]);
	if (cell3 != 0 && cell4 != 0) for(int j=12; j<FitPoints-12; j++) T34[j-12] = R3[j-6]*W4[j-6] - R4[j-6]*W3[j-6];
	else for(int j=12; j<FitPoints-12; j++) T34[j-12] = 0.0;
	
	//if (cell5 != 0 && cell6 != 0) for(int j=12; j<FitPoints-12; j++) T56[j-12] = asin(R5[j-6]*W6[j-6] - R6[j-6]*W5[j-6]);
	if (cell5 != 0 && cell6 != 0) for(int j=12; j<FitPoints-12; j++) T56[j-12] = R5[j-6]*W6[j-6] - R6[j-6]*W5[j-6];
	else for(int j=12; j<FitPoints-12; j++) T56[j-12] = 0.0;

	for(int j=0; j<TPoints; j++) // make a smaller T array
		{
		T12Short[j] = 0.0;
		T34Short[j] = 0.0;
		T56Short[j] = 0.0;

		//compute the T array of the linear combination of cells
		TShort[j] = C12 * T12Short[j] + C34 * T34Short[j] + C56 * T56Short[j];
		}
	
	if (sample==2) //For second probe period, average TAvgPts points of Time array, defining initial time = 0 
		{
		for(int j=0; j<TPoints; j++) //make a smaller Time array
			{
			TimeBase[j]=0.0;
			for(int i=0; i<TAvgPts; i++) //average TAvgPts points of T12,T34,T56, and TimeBase starting from light-on time 
				{
				TimeBase[j] += Fitdata[TAvgPts*j +i +12]; 
				
				T12Short[j] += T12[TAvgPts*j +i];
				T34Short[j] += T34[TAvgPts*j +i]; 
				T56Short[j] += T56[TAvgPts*j +i]; 
				}
				  
			T12Short[j] = T12Short[j]/(TAvgPts*1.0);
			T34Short[j] = T34Short[j]/(TAvgPts*1.0);
			T56Short[j] = T56Short[j]/(TAvgPts*1.0);
			
			//compute the T array of the linear combination of cells
			TShort[j] = C12 * T12Short[j] + C34 * T34Short[j] + C56 * T56Short[j];
			
			TimeBase[j]=TimeBase[j]/(TAvgPts*1.0);
			if(j == 0) TimeZero=TimeBase[j];
			TimeBase[j]=TimeBase[j]-TimeZero;
			}
		}
	if (sample==1) //For first probe period, average TAvgPts points of Time array, defining final time = 0
		{
		for(int j=TPoints-1; j>-1; j--) //make a smaller Time array
			{
			TimeBase[j]=0.0;
			for(int i=0; i<TAvgPts; i++) //average TAvgPts points of T12,T34,T56, and TimeBase setting t=0 at light-off time
				{
				TimeBase[j] += Fitdata[FitPoints-12 - (TPoints-j)*TAvgPts +i] ;
				
				T12Short[j] += T12[FitPoints-24 - (TPoints-j)*TAvgPts +i];
				T34Short[j] += T34[FitPoints-24 - (TPoints-j)*TAvgPts +i]; 
				T56Short[j] += T56[FitPoints-24 - (TPoints-j)*TAvgPts +i]; 
				}
			
			T12Short[j] = T12Short[j]/(TAvgPts*1.0);
			T34Short[j] = T34Short[j]/(TAvgPts*1.0);
			T56Short[j] = T56Short[j]/(TAvgPts*1.0);
			
			//compute the T array of the linear combination of cells
			TShort[j] = C12 * T12Short[j] + C34 * T34Short[j] + C56 * T56Short[j];
			
			TimeBase[j]=TimeBase[j]/(TAvgPts*1.0);
			if(j == TPoints-1) TimeZero=TimeBase[j];
			TimeBase[j]=TimeBase[j]-TimeZero;
			}
		}
				
	for (int k=0; k<TPoints; k++)
		{
		Sx  += TimeBase[k] ;
		Sxx += TimeBase[k] * TimeBase[k];
		Sy  += TShort[k];
		Sxy += TShort[k] * TimeBase[k];
		}
	
	Delta = TPoints*Sxx-Sx*Sx;
	
	*ComboDphi[sample-1][listPlace] = (Sxx*Sy-Sx*Sxy)/(Delta); 
	*ComboDw[sample-1][listPlace] = (TPoints*Sxy-Sx*Sy)/(Delta);   
	chi2 = 0.0; //initialize chi^2 to 0
	
	for (int l=0; l<TPoints; l++) //compute chi squared in order to get uncertainty estimates w/o error bars on individual points
		{
		chi2 += ((TShort[l])-*ComboDphi[sample-1][listPlace]-*ComboDw[sample-1][listPlace]*TimeBase[l])*((TShort[l])-*ComboDphi[sample-1][listPlace]-*ComboDw[sample-1][listPlace]*TimeBase[l]);
		}
	
	*ComboSphi[sample-1][listPlace] = sqrt(fabs(Sxx/Delta))*sqrt(chi2/(TPoints-2)); 
	*ComboSw[sample-1][listPlace] = sqrt(fabs(TPoints/Delta))*sqrt(chi2/(TPoints-2)); 
	
	free(R1);
	free(R2);
	free(R3);
	free(R4);
	free(R5);
	free(R6);
	free(W1);
	free(W2);
	free(W3);
	free(W4);
	free(W5);
	free(W6);
	free(T12);
	free(T34);
	free(T56);

	return 0;
	}


 /*
void ProductComboFit(int sample) //Takes data from multiple cells and creates a single T[] array 
//representing the frequency difference of the middle cells * 3 minus the difference of the outer cells
	{
	int err = 0, n = 0, i = 0, j = 0;	
	
	GetCtrlVal(aph,AP_TArrayAvgPts,&TAvgPts); 
	
	int TdiffPts = 0;
	
	int TPoints = floor((FitPoints-24)/TAvgPts);
	
	double TShort[TPoints];
	double TimeBase[TPoints];

	double TimeZero=0.0;

	double T[FitPoints-12];
	
	double s[4][FitPoints-6]; 
	double c[4][FitPoints-6]; 
	
	double SinCube[2][FitPoints-12];
	double CosCube[2][FitPoints-12];
	
	double TriSin[2][FitPoints-12];
	double TriCos[2][FitPoints-12];

	double Sin3MT3MB[FitPoints-12];
	double Cos3MT3MB[FitPoints-12];	
	
	double SinOTOB[FitPoints-12];
	double CosOTOB[FitPoints-12];

	double Sx = 0.0;
	double Sy = 0.0;
	double Sxx = 0.0;
	double Sxy = 0.0;
	double Delta = 0.0;
	double mean = 0;

	for (n=0; n<4; n++)
		{
		for(j=0; j<6; j++)
			{
			s[n][j] = 0.0;
			c[n][j] = 0.0;
			}
		}
	
	for(j=0; j<12; j++) 
		{
		T[j] = 0.0; 
		
		SinCube[0][j] = 0.0; 
		SinCube[1][j] = 0.0; 
		
		CosCube[0][j] = 0.0;  
		CosCube[1][j] = 0.0; 
		
		TriSin[0][j] = 0.0;
		TriSin[1][j] = 0.0;   
	
		TriCos[0][j] = 0.0;
		TriCos[1][j] = 0.0;   
	
		Sin3MT3MB[j] = 0.0;   
		Cos3MT3MB[j] = 1.0;   
	 	
		SinOTOB[j] = 0.0;   
		CosOTOB[j] = 1.0;   
		}
	
	//Normalize the data in S[][] by dividing out exponential decay function
	for (n=0; n<NCELLS; n++) for(i=6; i<FitPoints-6; i++) c[n][i] = sqrt(S[n][i]*S[n][i] - S[n][i-6]*S[n][i+6]);

	for (n=0; n<NCELLS; n++) for(i=6; i<FitPoints-6; i++) s[n][i] = S[n][i]/c[n][i];

	for (n=0; n<NCELLS; n++) for(i=12; i<FitPoints-12; i++) c[n][i] = 0.5*(s[n][i-6]-s[n][i+6]);
	
	for (j=12; j<FitPoints-12; j++)
		{
		//holder arrays for Sin^3(ThetaMT) 
		SinCube[0][j] = s[0][j]*s[0][j]*s[0][j];
		SinCube[1][j] = s[1][j]*s[1][j]*s[1][j];
		
		//holder arrays for Cos^3(ThetaMB) 
		CosCube[0][j] = c[0][j]*c[0][j]*c[0][j];
		CosCube[1][j] = c[1][j]*c[1][j]*c[1][j];

		//compute Sin(3ThetaMT) and Sin(3ThetaMB)
		TriSin[0][j] = 3*s[0][j] - 4*SinCube[0][j];
		TriSin[1][j] = 3*s[1][j] - 4*SinCube[1][j]; 
	
		//compute Cos(3ThetaMT) and Cos(3ThetaMB)
		TriCos[0][j] = 4*CosCube[0][j] - 3*c[0][j];
		TriCos[1][j] = 4*CosCube[1][j] - 3*c[1][j];
	
		//compute the difference Sin(3ThetaMT-3ThetaMB) and Cos(3ThetaMT-3ThetaMB)
		Sin3MT3MB[j] = TriSin[0][j]*TriCos[1][j] - TriCos[0][j]*TriSin[1][j];
		Cos3MT3MB[j] = TriCos[0][j]*TriCos[1][j] + TriSin[0][j]*TriSin[1][j];	
	
		//compute the difference Sin(ThetaOT-ThetaOB) and Cos(ThetaOT-ThetaOB)
		SinOTOB[j] = s[2][j]*c[3][j] - c[2][j]*s[3][j];
		CosOTOB[j] = c[2][j]*c[3][j] + s[2][j]*s[3][j];
	
		//define T[] as Sin(3ThetaMT-3ThetaMB-ThetaOT+ThetaOB)
		T[j] = Sin3MT3MB[j]*CosOTOB[j] - Cos3MT3MB[j]*SinOTOB[j];
		}	          
		
	if (sample==1) //For first probe period, average TAvgPts points of Time array, defining final time = 0
		{
		for(j=TPoints-1; j>-1; j--) //make a smaller Time array
			{
			TimeBase[j]=0.0;
			TShort[j]= 0.0;
			
			for(i=0; i<TAvgPts; i++) //average TAvgPts points of T and TimeBase setting t=0 at light-off time
				{
				TimeBase[j] += Fitdata[FitPoints - 12 - TAvgPts*(TPoints - j) + i] ;
				TShort[j] += T[FitPoints - 12 - TAvgPts*(TPoints - j) + i];
				}
			
			TimeBase[j] = TimeBase[j]/(TAvgPts*1.0);
			TShort[j] = TShort[j]/(TAvgPts*1.0);
			
			Tdiff[TshortPtsA * 6 + j] = -1.0*TShort[j];
			if(j==TPoints-1) TimeZero = TimeBase[j];
			TimeBase[j] = TimeBase[j]-TimeZero;
			}
		}

	if (sample==2) //For second probe period, average TAvgPts points of Time array, defining initial time = 0 
		{
		for(j=0; j<TPoints; j++) //make a smaller Time array
			{
			TimeBase[j]=0.0;
			TShort[j]= 0.0;
			for(i=0; i<TAvgPts; i++) //average TAvgPts points of T and TimeBase starting from light-on time 
				{
				TimeBase[j] += Fitdata[TAvgPts*j + i + 12]; 
				
				TShort[j] += T[TAvgPts*j + i + 12];
				}
			TShort[j] = TShort[j]/(TAvgPts*1.0);
			
			TimeBase[j] = TimeBase[j]/(TAvgPts*1.0);
			
			if(j==0) TimeZero = TimeBase[j];
			
			TimeBase[j] = TimeBase[j]-TimeZero;
			}
		
		TdiffPts = TshortPtsA;
		if(TshortPtsB < TshortPtsA) TdiffPts = TshortPtsB;

		TdiffDw[6] = 0.0; //initialize average, deviation sums
		TdiffDwErr[6] = 0.0;  
		for(int j=0; j<TdiffPts; j++)
			{
			Tdiff[TshortPtsA * 6 + j] += 1.0 *TShort[j]; //add value of Tshort to T difference array
			Tdiff[TshortPtsA * 6 + j] *= 1.0/(shutterOpenB+0.05-shutterOpenA-1.0); //divide by dark time to get freq. difference 
			TdiffDw[6] += Tdiff[TshortPtsA * 6 + j]/TdiffPts; //add value of Tshort to average value array
			}
		for(int j=0; j<TdiffPts; j++)
			{
			//take the sum of the squared deviations from the avg. divided by # of data pts. as the std. error of the mean
			TdiffDwErr[6] += ((TdiffDw[6]-Tdiff[TshortPtsA *(6)+j])*(TdiffDw[6]-Tdiff[TshortPtsA*(6)+j]))/(TdiffPts*(TdiffPts -1));
			}
		TdiffDwErr[6] = sqrt(TdiffDwErr[6]); 
		}
				
	for (int k=0; k<TPoints; k++)
		{
		Sx  += TimeBase[k] ;
		Sxx += TimeBase[k] * TimeBase[k];
		Sy  += TShort[k];
		Sxy += TShort[k] * TimeBase[k];
		}
	
	Delta = TPoints*Sxx-Sx*Sx;
	
	*ComboDphi[sample-1] = (Sxx*Sy-Sx*Sxy)/(Delta); 
	*ComboDw[sample-1] = (TPoints*Sxy-Sx*Sy)/(Delta);   
	
	chi2 = 0.0; //initialize chi^2 to 0
	
	// subtract the fit function from the data and compute chi squared 
	//in order to get uncertainty estimates w/o error bars on individual points   
	for (int l=0; l<TPoints; l++) chi2 += ((TShort[l])-*ComboDphi[sample-1]-*ComboDw[sample-1]*TimeBase[l])*((TShort[l])-*ComboDphi[sample-1]-*ComboDw[sample-1]*TimeBase[l]);
	
	*ComboSphi[sample-1] = sqrt(fabs(Sxx/Delta))*sqrt(chi2/(TPoints-2)); 
	*ComboSw[sample-1] = sqrt(fabs(TPoints/Delta))*sqrt(chi2/(TPoints-2)); 
	} 
*/

double fun(double x, double a[]) //returns the value of the fiting function given the parameters
	{
	double res;

    res=a[3]*sin(a[0]*(x-a[4])+a[2])*exp(-x/a[1]);
    return res;
	}    
    
static int Guess (void) //get initial parameter estimates to be passed to the fitting routine. Called by FitData
	{
  	double max1,max2,min;
  	int imax1,imax2,imin;
  	double pi=3.1415926535897932384;
  	double firstzero,lastzero;
	double tmid =0.0;
  	int zerocounter,k,i;
  	int qperiod,ifirst,skip=2;
        
	//tmid=(Fitdata[FitPoints-1]-Fitdata[0])*0.5;
	if(sample == 1) tmid = Fitdata[FitPoints-1];
	else tmid = Fitdata[0];
	
    for (k=0;k<NCELLS;k++) 
		{
		firstzero=0;
    	zerocounter=0;
    	for (i=0;i<FitPoints-1;i++)
			{
    		if (Fitdata[FitPoints*(k+1)+i]*Fitdata[FitPoints*(k+1)+i+1]<0) //signal crosses zero between points i, i+1 
				{
    			lastzero=(Fitdata[i]+Fitdata[i+1])/2; //get the time value for the zero crossing
    			if (firstzero==0) //if we don't have a time value for the first zero crossing of the sample
					{
    				firstzero=lastzero; //store the time of the zero crossing we just found as the first zero crossing
    				ifirst=i; //mark the index of the zero crossing we just found as index of the first zero crossing
    				}
    			zerocounter++;
    			i=i+skip;
    			}
			}
    	if(zerocounter>1) 
			{
    		coef[ncoef*k]=pi*(zerocounter-1)/(lastzero-firstzero);
    		coef[ncoef*k+2]=(-1.0)*fmod(coef[ncoef*k]*(firstzero),2*pi); //determine a guess for the initial signal phase, assuming that the phase is 0 at first zero crossing
    		qperiod=FitPoints/(zerocounter-1)/2;

    		if (Fitdata[FitPoints*(k+1)+ifirst+qperiod]<0) coef[ncoef*k+2]+=pi; //if the signal has negative slope at the first zero crossing, phase=pi
			coef[ncoef*k+2]=fmod(coef[ncoef*k+2]+coef[ncoef*k]*tmid,2*pi); //add the phase offset (frequency*midtime) for fitting to the midtime
    	
    		MaxMin1D (&Fitdata[FitPoints*(k+1)], 10*qperiod, &max1, &imax1, &min, &imin); 
    		MaxMin1D (&Fitdata[FitPoints*(k+2)-10*qperiod], 10*qperiod, &max2, &imax2, &min, &imin);
			
			coef[ncoef*k+1] = (Fitdata[imax2+FitPoints-10*qperiod]-Fitdata[imax1])/log(max1/max2);
    		coef[ncoef*k+3] = max1;
			coef[ncoef*k+4] = tmid;
    		
			ResetTextBox (aph, AP_Error,""); 
    		}
    	else 
			{
			ResetTextBox (aph, AP_Error,"could not guess coef"); //WCG 7-11-01 zero coefficients if you can't fit
			}   
		}
    	
	if(sample == 1)
		{
	    SetCtrlVal (aph, AP_w1_A,coef[0]);
	    SetCtrlVal (aph, AP_t1_A,coef[1]); 
	    SetCtrlVal (aph, AP_p1_A,coef[2]); 
	    SetCtrlVal (aph, AP_a1_A,coef[3]);
	    SetCtrlVal (aph, AP_w2_A,coef[5]);
	    SetCtrlVal (aph, AP_t2_A,coef[6]); 
	    SetCtrlVal (aph, AP_p2_A,coef[7]); 
	    SetCtrlVal (aph, AP_a2_A,coef[8]);
	    SetCtrlVal (aph, AP_w3_A,coef[10]);
	    SetCtrlVal (aph, AP_t3_A,coef[11]); 
	    SetCtrlVal (aph, AP_p3_A,coef[12]); 
	    SetCtrlVal (aph, AP_a3_A,coef[13]);
	    SetCtrlVal (aph, AP_w4_A,coef[15]);
	    SetCtrlVal (aph, AP_t4_A,coef[16]); 
	    SetCtrlVal (aph, AP_p4_A,coef[17]); 
	    SetCtrlVal (aph, AP_a4_A,coef[18]);
		}
	else if (sample == 2)
		{
	    SetCtrlVal (aph, AP_w1_B,coef[0]);
	    SetCtrlVal (aph, AP_t1_B,coef[1]); 
	    SetCtrlVal (aph, AP_p1_B,coef[2]); 
	    SetCtrlVal (aph, AP_a1_B,coef[3]);
	    SetCtrlVal (aph, AP_w2_B,coef[5]);
	    SetCtrlVal (aph, AP_t2_B,coef[6]); 
	    SetCtrlVal (aph, AP_p2_B,coef[7]); 
	    SetCtrlVal (aph, AP_a2_B,coef[8]);
	    SetCtrlVal (aph, AP_w3_B,coef[10]);
	    SetCtrlVal (aph, AP_t3_B,coef[11]); 
	    SetCtrlVal (aph, AP_p3_B,coef[12]); 
	    SetCtrlVal (aph, AP_a3_B,coef[13]);
	    SetCtrlVal (aph, AP_w4_B,coef[15]);
	    SetCtrlVal (aph, AP_t4_B,coef[16]); 
	    SetCtrlVal (aph, AP_p4_B,coef[17]); 
	    SetCtrlVal (aph, AP_a4_B,coef[18]);
		}
    	
    return 0;
	}

static int AddCum(void) //outputs fit parameters to the *.cum file
	{
	int n,k,i;
	int year,month,day,hour,min,sec;
	int yearOffset, monthOffset;
	int error = 0;
	int num,a1,a2,b1,b2;
	int ExpTime = 0;
	double time;
	double Pi=3.1415926535897932384;
	double dPhi = 0.0;
	double dPhiErr = 0.0;
	static double time0, w0=0;
	char time0filename[300];
	char paramstring[8000], timestring [200],timelabel[200],temp[50],lineBuffer [100];
	FILE *cfp;
    
	om=(coef[0]+coef[5])/2.;
    SetCtrlVal(aph, AP_FREQ, om);

	SetCtrlVal(aph,AP_Ind,8); //set status bar to "Save"
	
	GetFileDate(readfilename,&month,&day,&year);	
	GetFileTime(readfilename,&hour,&min,&sec);
	
	//calculate # of seconds elapsed since Series 7 began (12:00 a.m. on 11/15/2013)
	if (year == 2015) yearOffset =  412 * 86400; //1/1/2015 began 412 days after 11/15/2013
	if (year == 2014) yearOffset =   47 * 86400; //1/1/2014 began 47 days after 11/15/2013
	if (year == 2013) yearOffset = -318 * 86400; //1/1/2013 began 318 days before 11/15/2013
		
	if (month ==  1) monthOffset =   0 * 86400;
	if (month ==  2) monthOffset =  31 * 86400;
	if (month ==  3) monthOffset =  59 * 86400; //not accounting for any leap years
	if (month ==  4) monthOffset =  90 * 86400;
	if (month ==  5) monthOffset = 120 * 86400; 
	if (month ==  6) monthOffset = 151 * 86400; 
	if (month ==  7) monthOffset = 181 * 86400; 
	if (month ==  8) monthOffset = 212 * 86400; 
	if (month ==  9) monthOffset = 243 * 86400; 
	if (month == 10) monthOffset = 273 * 86400; 
	if (month == 11) monthOffset = 304 * 86400; 
	if (month == 12) monthOffset = 334 * 86400; 
	
	//add year offset, month offset, days, hours, minutes, seconds, 
	ExpTime = yearOffset + monthOffset + (day * 86400) + (hour * 3600) + (min * 60) + sec; 

	if (sernum==serstart && sample == 1)
		{
	 	cfp=fopen(cumfilename,"w"); //open file for writing  
		if(manw0) GetCtrlVal(aph,AP_REFW,&w0);
	 	else 
			{
	 		w0=0;
	 		for (i=0;i<NCELLS;++i) w0 += coef[i*ncoef];
	 		w0 /= NCELLS;
	 		}

		time0=hour*60+min+sec/60.;
		
			//the formatted list of parameters for the *.cum file
			//Note this format string cannot span multiple lines--compiler errors result
			sprintf(paramstring, "#%12s%13s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s%21s",
				"Run Number","Time","Omega 1A","Error","Omega 2A","Error","Omega 3A","Error","Omega 4A","Error",
				"Rel Time 1A","Error","Rel Time 2A","Error","Rel Time 3A","Error","Rel Time 4A","Error",
				"Amplitude 1A","Error","Amplitude 2A","Error","Amplitude 3A","Error","Amplitude 4A","Error",
				"Transmission 1A","Error","Transmission 2A","Error","Transmission 3A","Error","Transmission 4A","Error",
				"Midtime A","Error","Pump Points","Error","ShutterCloseA","Error", 
				"dphi12A","Error","dphi13A","Error","dphi14A","Error","dphi23A","Error","dphi24A","Error","dphi34A","Error",
				"Combo A","Error","Combo(2) A","Error","Leak Test A","Error","MT-(MB+OT)/2 A","Error","(MT+OB)/2-MB A","Error", 
				
				"Omega 1B","Error","Omega 2B","Error","Omega 3B","Error","Omega 4B","Error",
				"Rel Time 1B","Error","Rel Time 2B","Error","Rel Time 3B","Error","Rel Time 4B","Error",
				"Amplitude 1B","Error","Amplitude 2B","Error","Amplitude 3B","Error","Amplitude 4B","Error",
				"Transmission 1B","Error","Transmission 2B","Error","Transmission 3B","Error","Transmission 4B","Error",
				"Midtime B","Error","ShutterOpenB","Error", 
				"dphi12B","Error","dphi13B","Error","dphi14B","Error","dphi23B","Error","dphi24B","Error","dphi34B","Error",
				"Combo B","Error","Combo(2) B","Error","Leak Test B","Error","MT-(MB+OT)/2 B","Error","(MT+OB)/2-MB B","Error",
				"TdiffDw12","Error","TdiffDw13","Error","TdiffDw14","Error","TdiffDw23","Error","TdiffDw24","Error","TdiffDw34","Error", "DOmegaDot12A", "Error", "DOmegaDot12A", "Error"); 
			fprintf(cfp,"%s\n",paramstring);

		fclose(cfp);
		}
	
	GetFileTime(readfilename,&hour,&min,&sec);
	time=hour*60+min+sec/60.-time0;
	if (time<-1) time=time+24*60;
	
	cfp=fopen(cumfilename,"a"); //open file for appending 
	
	if (sample == 1) 
		{
		error = fprintf(cfp, "%13d%13d", sernum, ExpTime); //write the time and the run number into the file once for each run
		}
	
	if (sample == 2) 	  // replace B relaxation times with dark relaxation times
		{
		coef[1]=TDark1;
		coef[6]=TDark2;
		coef[11]=TDark3;
		coef[16]=TDark4;
		}
	
	for (k=0; k < ncoef+1; ++k) //append the parameters of the most recent fit to the cumulative file
		{	
		for (i=0; i<NCELLS; ++i) //loop over cells once for each fit parameter
			{
		 	if (k==0) error = fprintf(cfp,"%21.12e%21.12e",coef[i*ncoef]-w0,errors[i*ncoef]); //append frequencies (minus overall offset w0) and errors in scientific format
			else if (k<4 && k!=2) //eliminate phases (k=2) from *.cum file
				{
				error = fprintf(cfp,"%21.12g%21.12e",coef[k+ncoef*i],errors[k+ncoef*i]); //append relaxation times, amplitudes and phases as floating-points
				}
			else if (k == 4)  error = fprintf(cfp,"%21.12g%21.12e", mean[i+4*(sample-1)],0.0);  //append Transmission values, with 0.0 for error
			else if (k == 5)
				{
				//if (sample == 1) error = fprintf(cfp, "%21.12f%21.12f", 2*coef[(k-1)+ncoef*i]+dstart,0.0); //for midtime parameters, add start time of fit and print 0.0 for error bars
				//else if (sample == 2) error = fprintf(cfp, "%21.12f%21.12f", dstart,0.0);
				
				//for midtime parameters, add start time of fit and print 0.0 for error bars
				if (sample == 1) error = fprintf(cfp, "%21.12f%21.12f", MidtimeA, 0.0); //Midtime A = TimeZero (calc. in ProductFit)
				else if (sample == 2) error = fprintf(cfp, "%21.12f%21.12f", MidtimeB, 0.0); //Midtime B = TimeZero (calc. in ProductFit)
			
				break; //print only 1 midtime for each fit
				}
			}
		}
		
		if (sample == 1) 
			{
			error = fprintf(cfp, "%21.4u%21.12f", pumpPts, 0.0);
			error = fprintf(cfp, "%21.12f%21.12f", shutterCloseA, 0.0);
			}
		else if (sample == 2) error = fprintf(cfp, "%21.12f%21.12f", shutterOpenB, 0.0);
		
		/*
		error = fprintf(cfp, "%21.12e%21.12e", *Dphi[sample-1][0][1], *Sphi[sample-1][0][1]);
		error = fprintf(cfp, "%21.12e%21.12e", *Dphi[sample-1][0][2], *Sphi[sample-1][0][2]);
		error = fprintf(cfp, "%21.12e%21.12e", *Dphi[sample-1][0][3], *Sphi[sample-1][0][3]);
		error = fprintf(cfp, "%21.12e%21.12e", *Dphi[sample-1][1][2], *Sphi[sample-1][1][2]);
		error = fprintf(cfp, "%21.12e%21.12e", *Dphi[sample-1][1][3], *Sphi[sample-1][1][3]);
		error = fprintf(cfp, "%21.12e%21.12e", *Dphi[sample-1][2][3], *Sphi[sample-1][2][3]);
		*/
		
		error = fprintf(cfp, "%21.12e%21.12e", *Dw[sample-1][0][1], *Sw[sample-1][0][1]);
		error = fprintf(cfp, "%21.12e%21.12e", *Dw[sample-1][0][2], *Sw[sample-1][0][2]);
		error = fprintf(cfp, "%21.12e%21.12e", *Dw[sample-1][0][3], *Sw[sample-1][0][3]);
		error = fprintf(cfp, "%21.12e%21.12e", *Dw[sample-1][1][2], *Sw[sample-1][1][2]);
		error = fprintf(cfp, "%21.12e%21.12e", *Dw[sample-1][1][3], *Sw[sample-1][1][3]);
		error = fprintf(cfp, "%21.12e%21.12e", *Dw[sample-1][2][3], *Sw[sample-1][2][3]);
		
		//test to see if we can distinguish combo channel from random data: use this line for MT-MB cell difference (04/10/14)
		//fprintf(cfp, "%21.12e%21.12e", 170 * 5.0E-08 * rand()/(double)RAND_MAX , *Sphi[sample-1][0][1]);
		//test to see if we can distinguish combo channel from random data: use this line for OT-OB cell difference (04/10/14)
		//fprintf(cfp, "%21.12e%21.12e", 170 * 1.3E-07 * rand()/(double)RAND_MAX, *Sphi[sample-1][2][3]); 
		
		error = fprintf(cfp, "%21.12e%21.12e", *ComboDphi[sample-1][0], *ComboSphi[sample-1][0]);
		error = fprintf(cfp, "%21.12e%21.12e", *ComboDphi[sample-1][1], *ComboSphi[sample-1][1]);
		error = fprintf(cfp, "%21.12e%21.12e", *ComboDphi[sample-1][2], *ComboSphi[sample-1][2]);
		error = fprintf(cfp, "%21.12e%21.12e", *ComboDphi[sample-1][3], *ComboSphi[sample-1][3]);
		error = fprintf(cfp, "%21.12e%21.12e", *ComboDphi[sample-1][4], *ComboSphi[sample-1][4]);
		
		if(sample == 2)
			{
			for (int i=0; i<6; i++) error = fprintf(cfp, "%21.12e%21.12e", TdiffDw[i], TdiffDwErr[i]);
			
			error = fprintf(cfp, "%21.12e%21.12e", DOmegaDot12A, 0.0); //output quadratic fit coefficients for T12[] residuals 
			error = fprintf(cfp, "%21.12e%21.12e", DOmegaDot34A, 0.0);  //quadratic fit coefficients for T34[] residuals
			error = fprintf(cfp,"\n"); //add a new line character at the end of the write for sample 2
			}
		
		//outputs results of Thiel-Sen estimation for freq. differences in place of Tdiff results
		/*
		if(sample == 2)  
			{
			for (int i=0; i<6; i++) error = fprintf(cfp, "%21.12e%21.12e", TS_Dw[i], TdiffDwErr[i]);
			error = fprintf(cfp,"\n");//add a new line character at the end of the write for sample 2
			}
		*/
	fclose(cfp);
	
	n=sernum-serstart; //n is the number of runs completed in the series to this point
	
	Hist[n]=time; //the first n values of Hist are time values (up to 5000 scans)
	
	if (sample == 1)
		{
		//assign average frequency value to spots in the Hist array
		Hist[n+1*histmax] = 0.25*(coef[0]+coef[5]+coef[10]+coef[15]); 
		
		Hist[n+9*histmax]  = coef[3]; //amplitude values from previous fits
		Hist[n+10*histmax] = coef[8];
		Hist[n+11*histmax] = coef[13];
		Hist[n+12*histmax] = coef[18];
		}
	else if (sample == 2)
		{
		//assign average frequency value to spots in the Hist array 
		Hist[n+2*histmax]  = 0.25*(coef[0]+coef[5]+coef[10]+coef[15]); 
		
		//assign combo values (not divided by dark time) to Hist array space mapped to Hist_w   
		Hist[n+3*histmax]  = ((*Dphi[1][0][1]) - (*Dphi[0][0][1])) + (1/3.0)*((*Dphi[0][2][3]) - (*Dphi[1][2][3])); 
		
		Hist[n+4*histmax]  = *ComboDphi[1][0] - *ComboDphi[0][0];
		//Hist[n+4*histmax]  = *ComboDphi[1] - *ComboDphi[0]; 
		
		Hist[n+5*histmax]  = TDark1; //dark lifetimes  
		Hist[n+6*histmax]  = TDark2;
		Hist[n+7*histmax]  = TDark3;
		Hist[n+8*histmax]  = TDark4;
	
		Hist[n+13*histmax] = coef[3]; //amplitude values from previous fits
		Hist[n+14*histmax] = coef[8];
		Hist[n+15*histmax] = coef[13];
		Hist[n+16*histmax] = coef[18];
		}
	
	if (n>0 && sample == 2) //graph the parameter history for the run if we have any fits completed
		{
		DeleteGraphPlot (aph, AP_Hist_wAvg_A, -1,VAL_DELAYED_DRAW);
		DeleteGraphPlot (aph, AP_Hist_wAvg_B, -1,VAL_DELAYED_DRAW);
		DeleteGraphPlot (aph, AP_Hist_Combo,  -1,VAL_DELAYED_DRAW);
    	DeleteGraphPlot (aph, AP_Hist_TDark,  -1,VAL_DELAYED_DRAW);  
    	DeleteGraphPlot (aph, AP_Hist_Amp_A,  -1,VAL_DELAYED_DRAW);
    	DeleteGraphPlot (aph, AP_Hist_Amp_B,  -1,VAL_DELAYED_DRAW);  
    	
		SetCtrlAttribute (aph, AP_Hist_wAvg_A, ATTR_REFRESH_GRAPH, 0);
    	SetCtrlAttribute (aph, AP_Hist_wAvg_B, ATTR_REFRESH_GRAPH, 0);
    	SetCtrlAttribute (aph, AP_Hist_Combo,  ATTR_REFRESH_GRAPH, 0);
    	SetCtrlAttribute (aph, AP_Hist_TDark,  ATTR_REFRESH_GRAPH, 0);
    	SetCtrlAttribute (aph, AP_Hist_Amp_A,  ATTR_REFRESH_GRAPH, 0);
    	SetCtrlAttribute (aph, AP_Hist_Amp_B,  ATTR_REFRESH_GRAPH, 0);

       	PlotXY (aph, AP_Hist_wAvg_A,&Hist[0], &Hist[histmax],
       	n+1,VAL_DOUBLE, VAL_DOUBLE, VAL_SCATTER, VAL_EMPTY_SQUARE,
       	VAL_EMPTY_SQUARE, 1, VAL_WHITE);
       	
		PlotXY (aph, AP_Hist_wAvg_B,&Hist[0], &Hist[histmax*2],
       	n+1,VAL_DOUBLE, VAL_DOUBLE, VAL_SCATTER, VAL_EMPTY_SQUARE,
       	VAL_EMPTY_SQUARE, 1, VAL_BLUE);
		
		PlotXY (aph, AP_Hist_Combo,&Hist[0], &Hist[histmax*3],
	    n+1,VAL_DOUBLE, VAL_DOUBLE, VAL_SCATTER, VAL_EMPTY_SQUARE,
	    VAL_EMPTY_SQUARE, 1, VAL_GREEN);
		
       	PlotXY (aph, AP_Hist_Combo,&Hist[0], &Hist[histmax*4],
       	n+1,VAL_DOUBLE, VAL_DOUBLE, VAL_SCATTER, VAL_EMPTY_SQUARE,
       	VAL_EMPTY_SQUARE, 1, VAL_YELLOW);
		
		for (int k = 0; k<NCELLS; k++)
			{
			PlotXY (aph, AP_Hist_TDark,&Hist[0], &Hist[histmax*(5+k)],
       		n+1,VAL_DOUBLE, VAL_DOUBLE, VAL_SCATTER, VAL_EMPTY_SQUARE,
       		VAL_SOLID, 1, ColorArray[k]);
   	
			PlotXY (aph, AP_Hist_Amp_A,&Hist[0], &Hist[histmax*(9+k)],
	    	n+1,VAL_DOUBLE, VAL_DOUBLE, VAL_SCATTER, VAL_EMPTY_SQUARE,
	    	VAL_SOLID, 1, ColorArray[k]);
		
			PlotXY (aph, AP_Hist_Amp_B,&Hist[0], &Hist[histmax*(13+k)],
       		n+1,VAL_DOUBLE, VAL_DOUBLE, VAL_SCATTER, VAL_EMPTY_SQUARE,
			VAL_SOLID, 1, ColorArray[k]);
			}
    	
		SetCtrlAttribute (aph, AP_Hist_wAvg_A, ATTR_REFRESH_GRAPH, 1);
		SetCtrlAttribute (aph, AP_Hist_wAvg_B, ATTR_REFRESH_GRAPH, 1);
    	SetCtrlAttribute (aph, AP_Hist_Combo,  ATTR_REFRESH_GRAPH, 1); 
    	SetCtrlAttribute (aph, AP_Hist_TDark,  ATTR_REFRESH_GRAPH, 1); 
    	SetCtrlAttribute (aph, AP_Hist_Amp_A,  ATTR_REFRESH_GRAPH, 1);
		SetCtrlAttribute (aph, AP_Hist_Amp_B,  ATTR_REFRESH_GRAPH, 1);
    	}
	
	return 0; 
	}

int CVICALLBACK RefFreqOn (int panel, int control, int event, void *callbackData, int eventData1, int eventData2) 
	{
	switch (event) 
		{
		case EVENT_COMMIT:
			GetCtrlVal(aph,AP_REFON,&manw0);
			SetCtrlAttribute(aph,AP_REFW,ATTR_DIMMED,!manw0);
			break;
		}
	return 0;
	}

int CVICALLBACK Quit (int panel, int control, int event, void *callbackData, int eventData1, int eventData2)
	{
	if(event==EVENT_COMMIT) 
		{
		free(Rawdata);
		free(Fitdata);
		free(Analdata);
		free(Background);
		free(Resid);
		QuitUserInterface (0);
		}
	return 0;
	}

int CVICALLBACK FREQCB (int panel, int control, int event, void *callbackData, int eventData1, int eventData2)
	{
	switch (event)
		{
		case EVENT_VAL_CHANGED:
		   	GetCtrlVal(aph,AP_FREQ,&om);
			break;
		}
	return 0;
	}

int CVICALLBACK DataSeCB (int panel, int control, int event, void *callbackData, int eventData1, int eventData2)
	{
	switch (event)
		{
		case EVENT_COMMIT:
		   GetCtrlVal(aph, AP_DataSe, &DataSeFlag);
			break;
		}
	return 0;
	}



int CVICALLBACK Analyze_Seq (int panel, int control, int event, void *callbackData, int eventData1, int eventData2)
//automates the analysis of multiple sets of runs from a UI-specified master file list. 
//reads filelist, then automatically sets start, end file #s, times, etc. using file input
	{
	int i,checked,dum,w,items,error, size, hdle, cntl;
	int start,stop,totalruns=0,count,cols,lines,corr,B,MCh,OCh,PumpTime,Astart,Aend,Bstart,Bend;
	char FileList[100],line[500],*checkend;
	double *CumData;
	FILE *log;

	if(event==EVENT_COMMIT) 
		{
		GetCtrlVal(aph,AP_filelist,FileList);
		
		log=fopen(FileList,"r");
		
		do 
			{
			checkend=fgets(line,500,log);
			if (line[0] != '#') 
				{
				items=sscanf(line,"%d%d%d%d%d%d%d%d%d%d%d%d%d",&start,&stop,&start,&stop,&corr,&B,&MCh,&OCh,&PumpTime,&Astart,&Aend,&Bstart,&Bend);
				
				SetCtrlVal(aph,AP_SerStart, start);
				SetCtrlVal(aph,AP_SerStop, stop);
				SetCtrlVal(aph,AP_DataStartA, 1.0*Astart+1.0);
				SetCtrlVal(aph,AP_DataStopA, 1.0*Aend); 
				SetCtrlVal(aph,AP_DataStartB, 1.0*Bstart+1.0); 
				SetCtrlVal(aph,AP_DataStopB, 1.0*Bend); 
				
				sprintf(cumname,"%s%d-%d.cum",sumname,start,stop);
				ResetTextBox (aph, AP_CumName, cumname);
				sprintf(cumfilename,"%s%s",outdircum,cumname);
	           	DisableBreakOnLibraryErrors();
				error=GetFileSize(cumfilename,&size);
				EnableBreakOnLibraryErrors();
				if (error!=-1) 
					{
				   	SetCtrlVal(feh,FE_Error,"Cumulative File Exists");
					SetCtrlAttribute (feh, FE_NewName, ATTR_LABEL_TEXT,"New Cumulative File");
				   	ResetTextBox(feh,FE_NewName,cumname);
				   	InstallPopup(feh);	
			 		GetUserEvent(1, &hdle, &cntl);
	  	   			GetCtrlVal(feh,FE_NewName,cumname);
		  			RemovePopup(feh);
		  			if (cntl!=FE_OV) 
						{
		  				sprintf(cumfilename,"%s%s",outdircum,cumname);
		  				DisableBreakOnLibraryErrors();
				  		error=GetFileSize(cumfilename,&size);
				  		EnableBreakOnLibraryErrors();
				  	 	if (error!=-1) break;
				  		}
					}
				
				serstart = start;
				sernum = serstart;
				serstop = stop;
				
				do
					{
					AnalyzeFile();
					sernum++;
					} while (sernum <= serstop);
				}
			} while(checkend != NULL);
		}
	return 0;
	}
